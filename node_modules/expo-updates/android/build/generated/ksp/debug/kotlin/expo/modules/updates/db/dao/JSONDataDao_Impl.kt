package expo.modules.updates.db.dao

import android.database.Cursor
import androidx.room.EntityInsertionAdapter
import androidx.room.RoomDatabase
import androidx.room.RoomSQLiteQuery
import androidx.room.RoomSQLiteQuery.Companion.acquire
import androidx.room.SharedSQLiteStatement
import androidx.room.util.appendPlaceholders
import androidx.room.util.getColumnIndexOrThrow
import androidx.room.util.newStringBuilder
import androidx.room.util.query
import androidx.sqlite.db.SupportSQLiteStatement
import expo.modules.updates.db.Converters
import expo.modules.updates.db.entity.JSONDataEntity
import java.lang.Class
import java.lang.StringBuilder
import java.util.ArrayList
import java.util.Date
import javax.`annotation`.processing.Generated
import kotlin.Function1
import kotlin.Int
import kotlin.Long
import kotlin.String
import kotlin.Suppress
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableList
import kotlin.jvm.JvmStatic

@Generated(value = ["androidx.room.RoomProcessor"])
@Suppress(names = ["UNCHECKED_CAST", "DEPRECATION", "REDUNDANT_PROJECTION"])
public class JSONDataDao_Impl(
  __db: RoomDatabase,
) : JSONDataDao() {
  private val __db: RoomDatabase

  private val __insertionAdapterOfJSONDataEntity: EntityInsertionAdapter<JSONDataEntity>

  private val __converters: Converters = Converters()

  private val __preparedStmtOfDeleteJSONDataForKeyInternal: SharedSQLiteStatement
  init {
    this.__db = __db
    this.__insertionAdapterOfJSONDataEntity = object : EntityInsertionAdapter<JSONDataEntity>(__db)
        {
      protected override fun createQuery(): String =
          "INSERT OR ABORT INTO `json_data` (`key`,`value`,`last_updated`,`scope_key`,`id`) VALUES (?,?,?,?,nullif(?, 0))"

      protected override fun bind(statement: SupportSQLiteStatement, entity: JSONDataEntity) {
        statement.bindString(1, entity.key)
        statement.bindString(2, entity.value)
        val _tmp: Long? = __converters.dateToLong(entity.lastUpdated)
        if (_tmp == null) {
          statement.bindNull(3)
        } else {
          statement.bindLong(3, _tmp)
        }
        statement.bindString(4, entity.scopeKey)
        statement.bindLong(5, entity.id)
      }
    }
    this.__preparedStmtOfDeleteJSONDataForKeyInternal = object : SharedSQLiteStatement(__db) {
      public override fun createQuery(): String {
        val _query: String = "DELETE FROM json_data WHERE `key` = ? AND scope_key = ?;"
        return _query
      }
    }
  }

  protected override fun insertJSONDataInternal(jsonDataEntity: JSONDataEntity) {
    __db.assertNotSuspendingTransaction()
    __db.beginTransaction()
    try {
      __insertionAdapterOfJSONDataEntity.insert(jsonDataEntity)
      __db.setTransactionSuccessful()
    } finally {
      __db.endTransaction()
    }
  }

  public override fun setJSONStringForKey(
    key: JSONDataDao.JSONDataKey,
    `value`: String,
    scopeKey: String,
  ) {
    __db.beginTransaction()
    try {
      super@JSONDataDao_Impl.setJSONStringForKey(key, value, scopeKey)
      __db.setTransactionSuccessful()
    } finally {
      __db.endTransaction()
    }
  }

  public override fun setMultipleFields(fields: Map<JSONDataDao.JSONDataKey, String>,
      scopeKey: String) {
    __db.beginTransaction()
    try {
      super@JSONDataDao_Impl.setMultipleFields(fields, scopeKey)
      __db.setTransactionSuccessful()
    } finally {
      __db.endTransaction()
    }
  }

  public override fun updateJSONStringForKey(
    key: JSONDataDao.JSONDataKey,
    scopeKey: String,
    updater: Function1<String?, String>,
  ) {
    __db.beginTransaction()
    try {
      super@JSONDataDao_Impl.updateJSONStringForKey(key, scopeKey, updater)
      __db.setTransactionSuccessful()
    } finally {
      __db.endTransaction()
    }
  }

  public override fun deleteJSONDataForKeysForAllScopeKeys(keys: List<JSONDataDao.JSONDataKey>) {
    __db.beginTransaction()
    try {
      super@JSONDataDao_Impl.deleteJSONDataForKeysForAllScopeKeys(keys)
      __db.setTransactionSuccessful()
    } finally {
      __db.endTransaction()
    }
  }

  protected override fun deleteJSONDataForKeyInternal(key: String, scopeKey: String) {
    __db.assertNotSuspendingTransaction()
    val _stmt: SupportSQLiteStatement = __preparedStmtOfDeleteJSONDataForKeyInternal.acquire()
    var _argIndex: Int = 1
    _stmt.bindString(_argIndex, key)
    _argIndex = 2
    _stmt.bindString(_argIndex, scopeKey)
    try {
      __db.beginTransaction()
      try {
        _stmt.executeUpdateDelete()
        __db.setTransactionSuccessful()
      } finally {
        __db.endTransaction()
      }
    } finally {
      __preparedStmtOfDeleteJSONDataForKeyInternal.release(_stmt)
    }
  }

  protected override fun loadJSONDataForKeyInternal(key: String, scopeKey: String):
      List<JSONDataEntity> {
    val _sql: String =
        "SELECT * FROM json_data WHERE `key` = ? AND scope_key = ? ORDER BY last_updated DESC LIMIT 1;"
    val _statement: RoomSQLiteQuery = acquire(_sql, 2)
    var _argIndex: Int = 1
    _statement.bindString(_argIndex, key)
    _argIndex = 2
    _statement.bindString(_argIndex, scopeKey)
    __db.assertNotSuspendingTransaction()
    val _cursor: Cursor = query(__db, _statement, false, null)
    try {
      val _cursorIndexOfKey: Int = getColumnIndexOrThrow(_cursor, "key")
      val _cursorIndexOfValue: Int = getColumnIndexOrThrow(_cursor, "value")
      val _cursorIndexOfLastUpdated: Int = getColumnIndexOrThrow(_cursor, "last_updated")
      val _cursorIndexOfScopeKey: Int = getColumnIndexOrThrow(_cursor, "scope_key")
      val _cursorIndexOfId: Int = getColumnIndexOrThrow(_cursor, "id")
      val _result: MutableList<JSONDataEntity> = ArrayList<JSONDataEntity>(_cursor.getCount())
      while (_cursor.moveToNext()) {
        val _item: JSONDataEntity
        val _tmpKey: String
        _tmpKey = _cursor.getString(_cursorIndexOfKey)
        val _tmpValue: String
        _tmpValue = _cursor.getString(_cursorIndexOfValue)
        val _tmpLastUpdated: Date
        val _tmp: Long?
        if (_cursor.isNull(_cursorIndexOfLastUpdated)) {
          _tmp = null
        } else {
          _tmp = _cursor.getLong(_cursorIndexOfLastUpdated)
        }
        val _tmp_1: Date? = __converters.longToDate(_tmp)
        if (_tmp_1 == null) {
          error("Expected NON-NULL 'java.util.Date', but it was NULL.")
        } else {
          _tmpLastUpdated = _tmp_1
        }
        val _tmpScopeKey: String
        _tmpScopeKey = _cursor.getString(_cursorIndexOfScopeKey)
        _item = JSONDataEntity(_tmpKey,_tmpValue,_tmpLastUpdated,_tmpScopeKey)
        _item.id = _cursor.getLong(_cursorIndexOfId)
        _result.add(_item)
      }
      return _result
    } finally {
      _cursor.close()
      _statement.release()
    }
  }

  protected override fun deleteJSONDataForKeysForAllScopeKeysInternal(keys: List<String>) {
    __db.assertNotSuspendingTransaction()
    val _stringBuilder: StringBuilder = newStringBuilder()
    _stringBuilder.append("DELETE FROM json_data WHERE `key` IN (")
    val _inputSize: Int = keys.size
    appendPlaceholders(_stringBuilder, _inputSize)
    _stringBuilder.append(")")
    val _sql: String = _stringBuilder.toString()
    val _stmt: SupportSQLiteStatement = __db.compileStatement(_sql)
    var _argIndex: Int = 1
    for (_item: String in keys) {
      _stmt.bindString(_argIndex, _item)
      _argIndex++
    }
    __db.beginTransaction()
    try {
      _stmt.executeUpdateDelete()
      __db.setTransactionSuccessful()
    } finally {
      __db.endTransaction()
    }
  }

  public companion object {
    @JvmStatic
    public fun getRequiredConverters(): List<Class<*>> = emptyList()
  }
}
