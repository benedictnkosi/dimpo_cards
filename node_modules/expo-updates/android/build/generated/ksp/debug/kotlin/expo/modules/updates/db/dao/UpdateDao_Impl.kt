package expo.modules.updates.db.dao

import android.database.Cursor
import androidx.room.EntityDeletionOrUpdateAdapter
import androidx.room.EntityInsertionAdapter
import androidx.room.RoomDatabase
import androidx.room.RoomSQLiteQuery
import androidx.room.RoomSQLiteQuery.Companion.acquire
import androidx.room.SharedSQLiteStatement
import androidx.room.util.appendPlaceholders
import androidx.room.util.getColumnIndexOrThrow
import androidx.room.util.newStringBuilder
import androidx.room.util.query
import androidx.sqlite.db.SupportSQLiteStatement
import expo.modules.updates.db.Converters
import expo.modules.updates.db.entity.AssetEntity
import expo.modules.updates.db.entity.UpdateEntity
import expo.modules.updates.db.enums.UpdateStatus
import java.lang.Class
import java.lang.StringBuilder
import java.util.ArrayList
import java.util.Date
import java.util.UUID
import javax.`annotation`.processing.Generated
import kotlin.Boolean
import kotlin.ByteArray
import kotlin.Int
import kotlin.Long
import kotlin.String
import kotlin.Suppress
import kotlin.collections.List
import kotlin.collections.MutableList
import kotlin.jvm.JvmStatic
import org.json.JSONObject

@Generated(value = ["androidx.room.RoomProcessor"])
@Suppress(names = ["UNCHECKED_CAST", "DEPRECATION", "REDUNDANT_PROJECTION"])
public class UpdateDao_Impl(
  __db: RoomDatabase,
) : UpdateDao() {
  private val __db: RoomDatabase

  private val __insertionAdapterOfUpdateEntity: EntityInsertionAdapter<UpdateEntity>

  private val __converters: Converters = Converters()

  private val __deletionAdapterOfUpdateEntity: EntityDeletionOrUpdateAdapter<UpdateEntity>

  private val __preparedStmtOfKeepUpdate: SharedSQLiteStatement

  private val __preparedStmtOfMarkUpdateWithStatus: SharedSQLiteStatement

  private val __preparedStmtOf_setUpdateScopeKeyInternal: SharedSQLiteStatement

  private val __preparedStmtOfSetUpdateCommitTimeInternal: SharedSQLiteStatement

  private val __preparedStmtOfMarkUpdateAccessedInternal: SharedSQLiteStatement

  private val __preparedStmtOfIncrementSuccessfulLaunchCountInternal: SharedSQLiteStatement

  private val __preparedStmtOfIncrementFailedLaunchCountInternal: SharedSQLiteStatement
  init {
    this.__db = __db
    this.__insertionAdapterOfUpdateEntity = object : EntityInsertionAdapter<UpdateEntity>(__db) {
      protected override fun createQuery(): String =
          "INSERT OR ABORT INTO `updates` (`id`,`commit_time`,`runtime_version`,`scope_key`,`manifest`,`launch_asset_id`,`status`,`keep`,`last_accessed`,`successful_launch_count`,`failed_launch_count`) VALUES (?,?,?,?,?,?,?,?,?,?,?)"

      protected override fun bind(statement: SupportSQLiteStatement, entity: UpdateEntity) {
        val _tmp: ByteArray = __converters.uuidToBytes(entity.id)
        statement.bindBlob(1, _tmp)
        val _tmp_1: Long? = __converters.dateToLong(entity.commitTime)
        if (_tmp_1 == null) {
          statement.bindNull(2)
        } else {
          statement.bindLong(2, _tmp_1)
        }
        statement.bindString(3, entity.runtimeVersion)
        statement.bindString(4, entity.scopeKey)
        val _tmp_2: String? = __converters.jsonObjectToString(entity.manifest)
        if (_tmp_2 == null) {
          statement.bindNull(5)
        } else {
          statement.bindString(5, _tmp_2)
        }
        val _tmpLaunchAssetId: Long? = entity.launchAssetId
        if (_tmpLaunchAssetId == null) {
          statement.bindNull(6)
        } else {
          statement.bindLong(6, _tmpLaunchAssetId)
        }
        val _tmp_3: Int = __converters.statusToInt(entity.status)
        statement.bindLong(7, _tmp_3.toLong())
        val _tmp_4: Int = if (entity.keep) 1 else 0
        statement.bindLong(8, _tmp_4.toLong())
        val _tmp_5: Long? = __converters.dateToLong(entity.lastAccessed)
        if (_tmp_5 == null) {
          statement.bindNull(9)
        } else {
          statement.bindLong(9, _tmp_5)
        }
        statement.bindLong(10, entity.successfulLaunchCount.toLong())
        statement.bindLong(11, entity.failedLaunchCount.toLong())
      }
    }
    this.__deletionAdapterOfUpdateEntity = object :
        EntityDeletionOrUpdateAdapter<UpdateEntity>(__db) {
      protected override fun createQuery(): String = "DELETE FROM `updates` WHERE `id` = ?"

      protected override fun bind(statement: SupportSQLiteStatement, entity: UpdateEntity) {
        val _tmp: ByteArray = __converters.uuidToBytes(entity.id)
        statement.bindBlob(1, _tmp)
      }
    }
    this.__preparedStmtOfKeepUpdate = object : SharedSQLiteStatement(__db) {
      public override fun createQuery(): String {
        val _query: String = "UPDATE updates SET keep = 1 WHERE id = ?;"
        return _query
      }
    }
    this.__preparedStmtOfMarkUpdateWithStatus = object : SharedSQLiteStatement(__db) {
      public override fun createQuery(): String {
        val _query: String = "UPDATE updates SET status = ? WHERE id = ?;"
        return _query
      }
    }
    this.__preparedStmtOf_setUpdateScopeKeyInternal = object : SharedSQLiteStatement(__db) {
      public override fun createQuery(): String {
        val _query: String = "UPDATE updates SET scope_key = ? WHERE id = ?;"
        return _query
      }
    }
    this.__preparedStmtOfSetUpdateCommitTimeInternal = object : SharedSQLiteStatement(__db) {
      public override fun createQuery(): String {
        val _query: String = "UPDATE updates SET commit_time = ? WHERE id = ?;"
        return _query
      }
    }
    this.__preparedStmtOfMarkUpdateAccessedInternal = object : SharedSQLiteStatement(__db) {
      public override fun createQuery(): String {
        val _query: String = "UPDATE updates SET last_accessed = ? WHERE id = ?;"
        return _query
      }
    }
    this.__preparedStmtOfIncrementSuccessfulLaunchCountInternal = object :
        SharedSQLiteStatement(__db) {
      public override fun createQuery(): String {
        val _query: String =
            "UPDATE updates SET successful_launch_count = successful_launch_count + 1 WHERE id = ?;"
        return _query
      }
    }
    this.__preparedStmtOfIncrementFailedLaunchCountInternal = object : SharedSQLiteStatement(__db) {
      public override fun createQuery(): String {
        val _query: String =
            "UPDATE updates SET failed_launch_count = failed_launch_count + 1 WHERE id = ?;"
        return _query
      }
    }
  }

  public override fun insertUpdate(update: UpdateEntity) {
    __db.assertNotSuspendingTransaction()
    __db.beginTransaction()
    try {
      __insertionAdapterOfUpdateEntity.insert(update)
      __db.setTransactionSuccessful()
    } finally {
      __db.endTransaction()
    }
  }

  public override fun deleteUpdates(updates: List<UpdateEntity>) {
    __db.assertNotSuspendingTransaction()
    __db.beginTransaction()
    try {
      __deletionAdapterOfUpdateEntity.handleMultiple(updates)
      __db.setTransactionSuccessful()
    } finally {
      __db.endTransaction()
    }
  }

  public override fun markUpdateFinished(update: UpdateEntity, hasSkippedEmbeddedAssets: Boolean) {
    __db.beginTransaction()
    try {
      super@UpdateDao_Impl.markUpdateFinished(update, hasSkippedEmbeddedAssets)
      __db.setTransactionSuccessful()
    } finally {
      __db.endTransaction()
    }
  }

  protected override fun keepUpdate(id: UUID) {
    __db.assertNotSuspendingTransaction()
    val _stmt: SupportSQLiteStatement = __preparedStmtOfKeepUpdate.acquire()
    var _argIndex: Int = 1
    val _tmp: ByteArray = __converters.uuidToBytes(id)
    _stmt.bindBlob(_argIndex, _tmp)
    try {
      __db.beginTransaction()
      try {
        _stmt.executeUpdateDelete()
        __db.setTransactionSuccessful()
      } finally {
        __db.endTransaction()
      }
    } finally {
      __preparedStmtOfKeepUpdate.release(_stmt)
    }
  }

  protected override fun markUpdateWithStatus(status: UpdateStatus, id: UUID) {
    __db.assertNotSuspendingTransaction()
    val _stmt: SupportSQLiteStatement = __preparedStmtOfMarkUpdateWithStatus.acquire()
    var _argIndex: Int = 1
    val _tmp: Int = __converters.statusToInt(status)
    _stmt.bindLong(_argIndex, _tmp.toLong())
    _argIndex = 2
    val _tmp_1: ByteArray = __converters.uuidToBytes(id)
    _stmt.bindBlob(_argIndex, _tmp_1)
    try {
      __db.beginTransaction()
      try {
        _stmt.executeUpdateDelete()
        __db.setTransactionSuccessful()
      } finally {
        __db.endTransaction()
      }
    } finally {
      __preparedStmtOfMarkUpdateWithStatus.release(_stmt)
    }
  }

  public override fun _setUpdateScopeKeyInternal(id: UUID, newScopeKey: String) {
    __db.assertNotSuspendingTransaction()
    val _stmt: SupportSQLiteStatement = __preparedStmtOf_setUpdateScopeKeyInternal.acquire()
    var _argIndex: Int = 1
    _stmt.bindString(_argIndex, newScopeKey)
    _argIndex = 2
    val _tmp: ByteArray = __converters.uuidToBytes(id)
    _stmt.bindBlob(_argIndex, _tmp)
    try {
      __db.beginTransaction()
      try {
        _stmt.executeUpdateDelete()
        __db.setTransactionSuccessful()
      } finally {
        __db.endTransaction()
      }
    } finally {
      __preparedStmtOf_setUpdateScopeKeyInternal.release(_stmt)
    }
  }

  public override fun setUpdateCommitTimeInternal(id: UUID, commitTime: Date) {
    __db.assertNotSuspendingTransaction()
    val _stmt: SupportSQLiteStatement = __preparedStmtOfSetUpdateCommitTimeInternal.acquire()
    var _argIndex: Int = 1
    val _tmp: Long? = __converters.dateToLong(commitTime)
    if (_tmp == null) {
      _stmt.bindNull(_argIndex)
    } else {
      _stmt.bindLong(_argIndex, _tmp)
    }
    _argIndex = 2
    val _tmp_1: ByteArray = __converters.uuidToBytes(id)
    _stmt.bindBlob(_argIndex, _tmp_1)
    try {
      __db.beginTransaction()
      try {
        _stmt.executeUpdateDelete()
        __db.setTransactionSuccessful()
      } finally {
        __db.endTransaction()
      }
    } finally {
      __preparedStmtOfSetUpdateCommitTimeInternal.release(_stmt)
    }
  }

  protected override fun markUpdateAccessedInternal(id: UUID, lastAccessed: Date) {
    __db.assertNotSuspendingTransaction()
    val _stmt: SupportSQLiteStatement = __preparedStmtOfMarkUpdateAccessedInternal.acquire()
    var _argIndex: Int = 1
    val _tmp: Long? = __converters.dateToLong(lastAccessed)
    if (_tmp == null) {
      _stmt.bindNull(_argIndex)
    } else {
      _stmt.bindLong(_argIndex, _tmp)
    }
    _argIndex = 2
    val _tmp_1: ByteArray = __converters.uuidToBytes(id)
    _stmt.bindBlob(_argIndex, _tmp_1)
    try {
      __db.beginTransaction()
      try {
        _stmt.executeUpdateDelete()
        __db.setTransactionSuccessful()
      } finally {
        __db.endTransaction()
      }
    } finally {
      __preparedStmtOfMarkUpdateAccessedInternal.release(_stmt)
    }
  }

  protected override fun incrementSuccessfulLaunchCountInternal(id: UUID) {
    __db.assertNotSuspendingTransaction()
    val _stmt: SupportSQLiteStatement =
        __preparedStmtOfIncrementSuccessfulLaunchCountInternal.acquire()
    var _argIndex: Int = 1
    val _tmp: ByteArray = __converters.uuidToBytes(id)
    _stmt.bindBlob(_argIndex, _tmp)
    try {
      __db.beginTransaction()
      try {
        _stmt.executeUpdateDelete()
        __db.setTransactionSuccessful()
      } finally {
        __db.endTransaction()
      }
    } finally {
      __preparedStmtOfIncrementSuccessfulLaunchCountInternal.release(_stmt)
    }
  }

  public override fun incrementFailedLaunchCountInternal(id: UUID) {
    __db.assertNotSuspendingTransaction()
    val _stmt: SupportSQLiteStatement = __preparedStmtOfIncrementFailedLaunchCountInternal.acquire()
    var _argIndex: Int = 1
    val _tmp: ByteArray = __converters.uuidToBytes(id)
    _stmt.bindBlob(_argIndex, _tmp)
    try {
      __db.beginTransaction()
      try {
        _stmt.executeUpdateDelete()
        __db.setTransactionSuccessful()
      } finally {
        __db.endTransaction()
      }
    } finally {
      __preparedStmtOfIncrementFailedLaunchCountInternal.release(_stmt)
    }
  }

  protected override fun loadLaunchableUpdatesForProjectWithStatuses(scopeKey: String,
      statuses: List<UpdateStatus>): List<UpdateEntity> {
    val _stringBuilder: StringBuilder = newStringBuilder()
    _stringBuilder.append("SELECT * FROM updates WHERE scope_key = ")
    _stringBuilder.append("?")
    _stringBuilder.append(" AND (successful_launch_count > 0 OR failed_launch_count < 1) AND status IN (")
    val _inputSize: Int = statuses.size
    appendPlaceholders(_stringBuilder, _inputSize)
    _stringBuilder.append(");")
    val _sql: String = _stringBuilder.toString()
    val _argCount: Int = 1 + _inputSize
    val _statement: RoomSQLiteQuery = acquire(_sql, _argCount)
    var _argIndex: Int = 1
    _statement.bindString(_argIndex, scopeKey)
    _argIndex = 2
    for (_item: UpdateStatus in statuses) {
      val _tmp: Int = __converters.statusToInt(_item)
      _statement.bindLong(_argIndex, _tmp.toLong())
      _argIndex++
    }
    __db.assertNotSuspendingTransaction()
    val _cursor: Cursor = query(__db, _statement, false, null)
    try {
      val _cursorIndexOfId: Int = getColumnIndexOrThrow(_cursor, "id")
      val _cursorIndexOfCommitTime: Int = getColumnIndexOrThrow(_cursor, "commit_time")
      val _cursorIndexOfRuntimeVersion: Int = getColumnIndexOrThrow(_cursor, "runtime_version")
      val _cursorIndexOfScopeKey: Int = getColumnIndexOrThrow(_cursor, "scope_key")
      val _cursorIndexOfManifest: Int = getColumnIndexOrThrow(_cursor, "manifest")
      val _cursorIndexOfLaunchAssetId: Int = getColumnIndexOrThrow(_cursor, "launch_asset_id")
      val _cursorIndexOfStatus: Int = getColumnIndexOrThrow(_cursor, "status")
      val _cursorIndexOfKeep: Int = getColumnIndexOrThrow(_cursor, "keep")
      val _cursorIndexOfLastAccessed: Int = getColumnIndexOrThrow(_cursor, "last_accessed")
      val _cursorIndexOfSuccessfulLaunchCount: Int = getColumnIndexOrThrow(_cursor,
          "successful_launch_count")
      val _cursorIndexOfFailedLaunchCount: Int = getColumnIndexOrThrow(_cursor,
          "failed_launch_count")
      val _result: MutableList<UpdateEntity> = ArrayList<UpdateEntity>(_cursor.getCount())
      while (_cursor.moveToNext()) {
        val _item_1: UpdateEntity
        val _tmpId: UUID
        val _tmp_1: ByteArray
        _tmp_1 = _cursor.getBlob(_cursorIndexOfId)
        _tmpId = __converters.bytesToUuid(_tmp_1)
        val _tmpCommitTime: Date
        val _tmp_2: Long?
        if (_cursor.isNull(_cursorIndexOfCommitTime)) {
          _tmp_2 = null
        } else {
          _tmp_2 = _cursor.getLong(_cursorIndexOfCommitTime)
        }
        val _tmp_3: Date? = __converters.longToDate(_tmp_2)
        if (_tmp_3 == null) {
          error("Expected NON-NULL 'java.util.Date', but it was NULL.")
        } else {
          _tmpCommitTime = _tmp_3
        }
        val _tmpRuntimeVersion: String
        _tmpRuntimeVersion = _cursor.getString(_cursorIndexOfRuntimeVersion)
        val _tmpScopeKey: String
        _tmpScopeKey = _cursor.getString(_cursorIndexOfScopeKey)
        val _tmpManifest: JSONObject
        val _tmp_4: String?
        if (_cursor.isNull(_cursorIndexOfManifest)) {
          _tmp_4 = null
        } else {
          _tmp_4 = _cursor.getString(_cursorIndexOfManifest)
        }
        val _tmp_5: JSONObject? = __converters.stringToJsonObject(_tmp_4)
        if (_tmp_5 == null) {
          error("Expected NON-NULL 'org.json.JSONObject', but it was NULL.")
        } else {
          _tmpManifest = _tmp_5
        }
        _item_1 = UpdateEntity(_tmpId,_tmpCommitTime,_tmpRuntimeVersion,_tmpScopeKey,_tmpManifest)
        if (_cursor.isNull(_cursorIndexOfLaunchAssetId)) {
          _item_1.launchAssetId = null
        } else {
          _item_1.launchAssetId = _cursor.getLong(_cursorIndexOfLaunchAssetId)
        }
        val _tmp_6: Int
        _tmp_6 = _cursor.getInt(_cursorIndexOfStatus)
        _item_1.status = __converters.intToStatus(_tmp_6)
        val _tmp_7: Int
        _tmp_7 = _cursor.getInt(_cursorIndexOfKeep)
        _item_1.keep = _tmp_7 != 0
        val _tmp_8: Long?
        if (_cursor.isNull(_cursorIndexOfLastAccessed)) {
          _tmp_8 = null
        } else {
          _tmp_8 = _cursor.getLong(_cursorIndexOfLastAccessed)
        }
        val _tmp_9: Date? = __converters.longToDate(_tmp_8)
        if (_tmp_9 == null) {
          error("Expected NON-NULL 'java.util.Date', but it was NULL.")
        } else {
          _item_1.lastAccessed = _tmp_9
        }
        _item_1.successfulLaunchCount = _cursor.getInt(_cursorIndexOfSuccessfulLaunchCount)
        _item_1.failedLaunchCount = _cursor.getInt(_cursorIndexOfFailedLaunchCount)
        _result.add(_item_1)
      }
      return _result
    } finally {
      _cursor.close()
      _statement.release()
    }
  }

  protected override fun loadUpdatesWithId(id: UUID): List<UpdateEntity> {
    val _sql: String = "SELECT * FROM updates WHERE id = ?;"
    val _statement: RoomSQLiteQuery = acquire(_sql, 1)
    var _argIndex: Int = 1
    val _tmp: ByteArray = __converters.uuidToBytes(id)
    _statement.bindBlob(_argIndex, _tmp)
    __db.assertNotSuspendingTransaction()
    val _cursor: Cursor = query(__db, _statement, false, null)
    try {
      val _cursorIndexOfId: Int = getColumnIndexOrThrow(_cursor, "id")
      val _cursorIndexOfCommitTime: Int = getColumnIndexOrThrow(_cursor, "commit_time")
      val _cursorIndexOfRuntimeVersion: Int = getColumnIndexOrThrow(_cursor, "runtime_version")
      val _cursorIndexOfScopeKey: Int = getColumnIndexOrThrow(_cursor, "scope_key")
      val _cursorIndexOfManifest: Int = getColumnIndexOrThrow(_cursor, "manifest")
      val _cursorIndexOfLaunchAssetId: Int = getColumnIndexOrThrow(_cursor, "launch_asset_id")
      val _cursorIndexOfStatus: Int = getColumnIndexOrThrow(_cursor, "status")
      val _cursorIndexOfKeep: Int = getColumnIndexOrThrow(_cursor, "keep")
      val _cursorIndexOfLastAccessed: Int = getColumnIndexOrThrow(_cursor, "last_accessed")
      val _cursorIndexOfSuccessfulLaunchCount: Int = getColumnIndexOrThrow(_cursor,
          "successful_launch_count")
      val _cursorIndexOfFailedLaunchCount: Int = getColumnIndexOrThrow(_cursor,
          "failed_launch_count")
      val _result: MutableList<UpdateEntity> = ArrayList<UpdateEntity>(_cursor.getCount())
      while (_cursor.moveToNext()) {
        val _item: UpdateEntity
        val _tmpId: UUID
        val _tmp_1: ByteArray
        _tmp_1 = _cursor.getBlob(_cursorIndexOfId)
        _tmpId = __converters.bytesToUuid(_tmp_1)
        val _tmpCommitTime: Date
        val _tmp_2: Long?
        if (_cursor.isNull(_cursorIndexOfCommitTime)) {
          _tmp_2 = null
        } else {
          _tmp_2 = _cursor.getLong(_cursorIndexOfCommitTime)
        }
        val _tmp_3: Date? = __converters.longToDate(_tmp_2)
        if (_tmp_3 == null) {
          error("Expected NON-NULL 'java.util.Date', but it was NULL.")
        } else {
          _tmpCommitTime = _tmp_3
        }
        val _tmpRuntimeVersion: String
        _tmpRuntimeVersion = _cursor.getString(_cursorIndexOfRuntimeVersion)
        val _tmpScopeKey: String
        _tmpScopeKey = _cursor.getString(_cursorIndexOfScopeKey)
        val _tmpManifest: JSONObject
        val _tmp_4: String?
        if (_cursor.isNull(_cursorIndexOfManifest)) {
          _tmp_4 = null
        } else {
          _tmp_4 = _cursor.getString(_cursorIndexOfManifest)
        }
        val _tmp_5: JSONObject? = __converters.stringToJsonObject(_tmp_4)
        if (_tmp_5 == null) {
          error("Expected NON-NULL 'org.json.JSONObject', but it was NULL.")
        } else {
          _tmpManifest = _tmp_5
        }
        _item = UpdateEntity(_tmpId,_tmpCommitTime,_tmpRuntimeVersion,_tmpScopeKey,_tmpManifest)
        if (_cursor.isNull(_cursorIndexOfLaunchAssetId)) {
          _item.launchAssetId = null
        } else {
          _item.launchAssetId = _cursor.getLong(_cursorIndexOfLaunchAssetId)
        }
        val _tmp_6: Int
        _tmp_6 = _cursor.getInt(_cursorIndexOfStatus)
        _item.status = __converters.intToStatus(_tmp_6)
        val _tmp_7: Int
        _tmp_7 = _cursor.getInt(_cursorIndexOfKeep)
        _item.keep = _tmp_7 != 0
        val _tmp_8: Long?
        if (_cursor.isNull(_cursorIndexOfLastAccessed)) {
          _tmp_8 = null
        } else {
          _tmp_8 = _cursor.getLong(_cursorIndexOfLastAccessed)
        }
        val _tmp_9: Date? = __converters.longToDate(_tmp_8)
        if (_tmp_9 == null) {
          error("Expected NON-NULL 'java.util.Date', but it was NULL.")
        } else {
          _item.lastAccessed = _tmp_9
        }
        _item.successfulLaunchCount = _cursor.getInt(_cursorIndexOfSuccessfulLaunchCount)
        _item.failedLaunchCount = _cursor.getInt(_cursorIndexOfFailedLaunchCount)
        _result.add(_item)
      }
      return _result
    } finally {
      _cursor.close()
      _statement.release()
    }
  }

  protected override fun loadLaunchAssetForUpdateInternal(updateId: UUID): AssetEntity? {
    val _sql: String =
        "SELECT assets.* FROM assets INNER JOIN updates ON updates.launch_asset_id = assets.id WHERE updates.id = ?;"
    val _statement: RoomSQLiteQuery = acquire(_sql, 1)
    var _argIndex: Int = 1
    val _tmp: ByteArray = __converters.uuidToBytes(updateId)
    _statement.bindBlob(_argIndex, _tmp)
    __db.assertNotSuspendingTransaction()
    val _cursor: Cursor = query(__db, _statement, false, null)
    try {
      val _cursorIndexOfKey: Int = getColumnIndexOrThrow(_cursor, "key")
      val _cursorIndexOfType: Int = getColumnIndexOrThrow(_cursor, "type")
      val _cursorIndexOfId: Int = getColumnIndexOrThrow(_cursor, "id")
      val _cursorIndexOfUrl: Int = getColumnIndexOrThrow(_cursor, "url")
      val _cursorIndexOfHeaders: Int = getColumnIndexOrThrow(_cursor, "headers")
      val _cursorIndexOfExtraRequestHeaders: Int = getColumnIndexOrThrow(_cursor,
          "extra_request_headers")
      val _cursorIndexOfMetadata: Int = getColumnIndexOrThrow(_cursor, "metadata")
      val _cursorIndexOfDownloadTime: Int = getColumnIndexOrThrow(_cursor, "download_time")
      val _cursorIndexOfRelativePath: Int = getColumnIndexOrThrow(_cursor, "relative_path")
      val _cursorIndexOfHash: Int = getColumnIndexOrThrow(_cursor, "hash")
      val _cursorIndexOfHashType: Int = getColumnIndexOrThrow(_cursor, "hash_type")
      val _cursorIndexOfExpectedHash: Int = getColumnIndexOrThrow(_cursor, "expected_hash")
      val _cursorIndexOfMarkedForDeletion: Int = getColumnIndexOrThrow(_cursor,
          "marked_for_deletion")
      val _result: AssetEntity?
      if (_cursor.moveToFirst()) {
        val _tmpKey: String?
        if (_cursor.isNull(_cursorIndexOfKey)) {
          _tmpKey = null
        } else {
          _tmpKey = _cursor.getString(_cursorIndexOfKey)
        }
        val _tmpType: String?
        if (_cursor.isNull(_cursorIndexOfType)) {
          _tmpType = null
        } else {
          _tmpType = _cursor.getString(_cursorIndexOfType)
        }
        _result = AssetEntity(_tmpKey,_tmpType)
        _result.id = _cursor.getLong(_cursorIndexOfId)
        val _tmp_1: String?
        if (_cursor.isNull(_cursorIndexOfUrl)) {
          _tmp_1 = null
        } else {
          _tmp_1 = _cursor.getString(_cursorIndexOfUrl)
        }
        _result.url = __converters.stringToUri(_tmp_1)
        val _tmp_2: String?
        if (_cursor.isNull(_cursorIndexOfHeaders)) {
          _tmp_2 = null
        } else {
          _tmp_2 = _cursor.getString(_cursorIndexOfHeaders)
        }
        _result.headers = __converters.stringToJsonObject(_tmp_2)
        val _tmp_3: String?
        if (_cursor.isNull(_cursorIndexOfExtraRequestHeaders)) {
          _tmp_3 = null
        } else {
          _tmp_3 = _cursor.getString(_cursorIndexOfExtraRequestHeaders)
        }
        _result.extraRequestHeaders = __converters.stringToJsonObject(_tmp_3)
        val _tmp_4: String?
        if (_cursor.isNull(_cursorIndexOfMetadata)) {
          _tmp_4 = null
        } else {
          _tmp_4 = _cursor.getString(_cursorIndexOfMetadata)
        }
        _result.metadata = __converters.stringToJsonObject(_tmp_4)
        val _tmp_5: Long?
        if (_cursor.isNull(_cursorIndexOfDownloadTime)) {
          _tmp_5 = null
        } else {
          _tmp_5 = _cursor.getLong(_cursorIndexOfDownloadTime)
        }
        _result.downloadTime = __converters.longToDate(_tmp_5)
        if (_cursor.isNull(_cursorIndexOfRelativePath)) {
          _result.relativePath = null
        } else {
          _result.relativePath = _cursor.getString(_cursorIndexOfRelativePath)
        }
        if (_cursor.isNull(_cursorIndexOfHash)) {
          _result.hash = null
        } else {
          _result.hash = _cursor.getBlob(_cursorIndexOfHash)
        }
        val _tmp_6: Int
        _tmp_6 = _cursor.getInt(_cursorIndexOfHashType)
        _result.hashType = __converters.intToHashType(_tmp_6)
        if (_cursor.isNull(_cursorIndexOfExpectedHash)) {
          _result.expectedHash = null
        } else {
          _result.expectedHash = _cursor.getString(_cursorIndexOfExpectedHash)
        }
        val _tmp_7: Int
        _tmp_7 = _cursor.getInt(_cursorIndexOfMarkedForDeletion)
        _result.markedForDeletion = _tmp_7 != 0
      } else {
        _result = null
      }
      return _result
    } finally {
      _cursor.close()
      _statement.release()
    }
  }

  public override fun loadAllUpdates(): List<UpdateEntity> {
    val _sql: String = "SELECT * FROM updates;"
    val _statement: RoomSQLiteQuery = acquire(_sql, 0)
    __db.assertNotSuspendingTransaction()
    val _cursor: Cursor = query(__db, _statement, false, null)
    try {
      val _cursorIndexOfId: Int = getColumnIndexOrThrow(_cursor, "id")
      val _cursorIndexOfCommitTime: Int = getColumnIndexOrThrow(_cursor, "commit_time")
      val _cursorIndexOfRuntimeVersion: Int = getColumnIndexOrThrow(_cursor, "runtime_version")
      val _cursorIndexOfScopeKey: Int = getColumnIndexOrThrow(_cursor, "scope_key")
      val _cursorIndexOfManifest: Int = getColumnIndexOrThrow(_cursor, "manifest")
      val _cursorIndexOfLaunchAssetId: Int = getColumnIndexOrThrow(_cursor, "launch_asset_id")
      val _cursorIndexOfStatus: Int = getColumnIndexOrThrow(_cursor, "status")
      val _cursorIndexOfKeep: Int = getColumnIndexOrThrow(_cursor, "keep")
      val _cursorIndexOfLastAccessed: Int = getColumnIndexOrThrow(_cursor, "last_accessed")
      val _cursorIndexOfSuccessfulLaunchCount: Int = getColumnIndexOrThrow(_cursor,
          "successful_launch_count")
      val _cursorIndexOfFailedLaunchCount: Int = getColumnIndexOrThrow(_cursor,
          "failed_launch_count")
      val _result: MutableList<UpdateEntity> = ArrayList<UpdateEntity>(_cursor.getCount())
      while (_cursor.moveToNext()) {
        val _item: UpdateEntity
        val _tmpId: UUID
        val _tmp: ByteArray
        _tmp = _cursor.getBlob(_cursorIndexOfId)
        _tmpId = __converters.bytesToUuid(_tmp)
        val _tmpCommitTime: Date
        val _tmp_1: Long?
        if (_cursor.isNull(_cursorIndexOfCommitTime)) {
          _tmp_1 = null
        } else {
          _tmp_1 = _cursor.getLong(_cursorIndexOfCommitTime)
        }
        val _tmp_2: Date? = __converters.longToDate(_tmp_1)
        if (_tmp_2 == null) {
          error("Expected NON-NULL 'java.util.Date', but it was NULL.")
        } else {
          _tmpCommitTime = _tmp_2
        }
        val _tmpRuntimeVersion: String
        _tmpRuntimeVersion = _cursor.getString(_cursorIndexOfRuntimeVersion)
        val _tmpScopeKey: String
        _tmpScopeKey = _cursor.getString(_cursorIndexOfScopeKey)
        val _tmpManifest: JSONObject
        val _tmp_3: String?
        if (_cursor.isNull(_cursorIndexOfManifest)) {
          _tmp_3 = null
        } else {
          _tmp_3 = _cursor.getString(_cursorIndexOfManifest)
        }
        val _tmp_4: JSONObject? = __converters.stringToJsonObject(_tmp_3)
        if (_tmp_4 == null) {
          error("Expected NON-NULL 'org.json.JSONObject', but it was NULL.")
        } else {
          _tmpManifest = _tmp_4
        }
        _item = UpdateEntity(_tmpId,_tmpCommitTime,_tmpRuntimeVersion,_tmpScopeKey,_tmpManifest)
        if (_cursor.isNull(_cursorIndexOfLaunchAssetId)) {
          _item.launchAssetId = null
        } else {
          _item.launchAssetId = _cursor.getLong(_cursorIndexOfLaunchAssetId)
        }
        val _tmp_5: Int
        _tmp_5 = _cursor.getInt(_cursorIndexOfStatus)
        _item.status = __converters.intToStatus(_tmp_5)
        val _tmp_6: Int
        _tmp_6 = _cursor.getInt(_cursorIndexOfKeep)
        _item.keep = _tmp_6 != 0
        val _tmp_7: Long?
        if (_cursor.isNull(_cursorIndexOfLastAccessed)) {
          _tmp_7 = null
        } else {
          _tmp_7 = _cursor.getLong(_cursorIndexOfLastAccessed)
        }
        val _tmp_8: Date? = __converters.longToDate(_tmp_7)
        if (_tmp_8 == null) {
          error("Expected NON-NULL 'java.util.Date', but it was NULL.")
        } else {
          _item.lastAccessed = _tmp_8
        }
        _item.successfulLaunchCount = _cursor.getInt(_cursorIndexOfSuccessfulLaunchCount)
        _item.failedLaunchCount = _cursor.getInt(_cursorIndexOfFailedLaunchCount)
        _result.add(_item)
      }
      return _result
    } finally {
      _cursor.close()
      _statement.release()
    }
  }

  public override fun loadAllUpdatesWithStatus(status: UpdateStatus): List<UpdateEntity> {
    val _sql: String = "SELECT * FROM updates WHERE status = ?;"
    val _statement: RoomSQLiteQuery = acquire(_sql, 1)
    var _argIndex: Int = 1
    val _tmp: Int = __converters.statusToInt(status)
    _statement.bindLong(_argIndex, _tmp.toLong())
    __db.assertNotSuspendingTransaction()
    val _cursor: Cursor = query(__db, _statement, false, null)
    try {
      val _cursorIndexOfId: Int = getColumnIndexOrThrow(_cursor, "id")
      val _cursorIndexOfCommitTime: Int = getColumnIndexOrThrow(_cursor, "commit_time")
      val _cursorIndexOfRuntimeVersion: Int = getColumnIndexOrThrow(_cursor, "runtime_version")
      val _cursorIndexOfScopeKey: Int = getColumnIndexOrThrow(_cursor, "scope_key")
      val _cursorIndexOfManifest: Int = getColumnIndexOrThrow(_cursor, "manifest")
      val _cursorIndexOfLaunchAssetId: Int = getColumnIndexOrThrow(_cursor, "launch_asset_id")
      val _cursorIndexOfStatus: Int = getColumnIndexOrThrow(_cursor, "status")
      val _cursorIndexOfKeep: Int = getColumnIndexOrThrow(_cursor, "keep")
      val _cursorIndexOfLastAccessed: Int = getColumnIndexOrThrow(_cursor, "last_accessed")
      val _cursorIndexOfSuccessfulLaunchCount: Int = getColumnIndexOrThrow(_cursor,
          "successful_launch_count")
      val _cursorIndexOfFailedLaunchCount: Int = getColumnIndexOrThrow(_cursor,
          "failed_launch_count")
      val _result: MutableList<UpdateEntity> = ArrayList<UpdateEntity>(_cursor.getCount())
      while (_cursor.moveToNext()) {
        val _item: UpdateEntity
        val _tmpId: UUID
        val _tmp_1: ByteArray
        _tmp_1 = _cursor.getBlob(_cursorIndexOfId)
        _tmpId = __converters.bytesToUuid(_tmp_1)
        val _tmpCommitTime: Date
        val _tmp_2: Long?
        if (_cursor.isNull(_cursorIndexOfCommitTime)) {
          _tmp_2 = null
        } else {
          _tmp_2 = _cursor.getLong(_cursorIndexOfCommitTime)
        }
        val _tmp_3: Date? = __converters.longToDate(_tmp_2)
        if (_tmp_3 == null) {
          error("Expected NON-NULL 'java.util.Date', but it was NULL.")
        } else {
          _tmpCommitTime = _tmp_3
        }
        val _tmpRuntimeVersion: String
        _tmpRuntimeVersion = _cursor.getString(_cursorIndexOfRuntimeVersion)
        val _tmpScopeKey: String
        _tmpScopeKey = _cursor.getString(_cursorIndexOfScopeKey)
        val _tmpManifest: JSONObject
        val _tmp_4: String?
        if (_cursor.isNull(_cursorIndexOfManifest)) {
          _tmp_4 = null
        } else {
          _tmp_4 = _cursor.getString(_cursorIndexOfManifest)
        }
        val _tmp_5: JSONObject? = __converters.stringToJsonObject(_tmp_4)
        if (_tmp_5 == null) {
          error("Expected NON-NULL 'org.json.JSONObject', but it was NULL.")
        } else {
          _tmpManifest = _tmp_5
        }
        _item = UpdateEntity(_tmpId,_tmpCommitTime,_tmpRuntimeVersion,_tmpScopeKey,_tmpManifest)
        if (_cursor.isNull(_cursorIndexOfLaunchAssetId)) {
          _item.launchAssetId = null
        } else {
          _item.launchAssetId = _cursor.getLong(_cursorIndexOfLaunchAssetId)
        }
        val _tmp_6: Int
        _tmp_6 = _cursor.getInt(_cursorIndexOfStatus)
        _item.status = __converters.intToStatus(_tmp_6)
        val _tmp_7: Int
        _tmp_7 = _cursor.getInt(_cursorIndexOfKeep)
        _item.keep = _tmp_7 != 0
        val _tmp_8: Long?
        if (_cursor.isNull(_cursorIndexOfLastAccessed)) {
          _tmp_8 = null
        } else {
          _tmp_8 = _cursor.getLong(_cursorIndexOfLastAccessed)
        }
        val _tmp_9: Date? = __converters.longToDate(_tmp_8)
        if (_tmp_9 == null) {
          error("Expected NON-NULL 'java.util.Date', but it was NULL.")
        } else {
          _item.lastAccessed = _tmp_9
        }
        _item.successfulLaunchCount = _cursor.getInt(_cursorIndexOfSuccessfulLaunchCount)
        _item.failedLaunchCount = _cursor.getInt(_cursorIndexOfFailedLaunchCount)
        _result.add(_item)
      }
      return _result
    } finally {
      _cursor.close()
      _statement.release()
    }
  }

  public override fun loadAllUpdateIdsWithStatus(status: UpdateStatus): List<UUID> {
    val _sql: String = "SELECT id FROM updates WHERE status = ?;"
    val _statement: RoomSQLiteQuery = acquire(_sql, 1)
    var _argIndex: Int = 1
    val _tmp: Int = __converters.statusToInt(status)
    _statement.bindLong(_argIndex, _tmp.toLong())
    __db.assertNotSuspendingTransaction()
    val _cursor: Cursor = query(__db, _statement, false, null)
    try {
      val _result: MutableList<UUID> = ArrayList<UUID>(_cursor.getCount())
      while (_cursor.moveToNext()) {
        val _item: UUID
        val _tmp_1: ByteArray
        _tmp_1 = _cursor.getBlob(0)
        _item = __converters.bytesToUuid(_tmp_1)
        _result.add(_item)
      }
      return _result
    } finally {
      _cursor.close()
      _statement.release()
    }
  }

  public override fun loadRecentUpdateIdsWithFailedLaunch(): List<UUID> {
    val _sql: String =
        "SELECT id FROM updates WHERE failed_launch_count > 0 ORDER BY commit_time DESC LIMIT 5;"
    val _statement: RoomSQLiteQuery = acquire(_sql, 0)
    __db.assertNotSuspendingTransaction()
    val _cursor: Cursor = query(__db, _statement, false, null)
    try {
      val _result: MutableList<UUID> = ArrayList<UUID>(_cursor.getCount())
      while (_cursor.moveToNext()) {
        val _item: UUID
        val _tmp: ByteArray
        _tmp = _cursor.getBlob(0)
        _item = __converters.bytesToUuid(_tmp)
        _result.add(_item)
      }
      return _result
    } finally {
      _cursor.close()
      _statement.release()
    }
  }

  protected override fun markUpdatesWithMissingAssets(missingAssetIds: List<Long>,
      status: UpdateStatus) {
    __db.assertNotSuspendingTransaction()
    val _stringBuilder: StringBuilder = newStringBuilder()
    _stringBuilder.append("UPDATE updates SET status = ")
    _stringBuilder.append("?")
    _stringBuilder.append(" WHERE id IN (SELECT DISTINCT update_id FROM updates_assets WHERE asset_id IN (")
    val _inputSize: Int = missingAssetIds.size
    appendPlaceholders(_stringBuilder, _inputSize)
    _stringBuilder.append("));")
    val _sql: String = _stringBuilder.toString()
    val _stmt: SupportSQLiteStatement = __db.compileStatement(_sql)
    var _argIndex: Int = 1
    val _tmp: Int = __converters.statusToInt(status)
    _stmt.bindLong(_argIndex, _tmp.toLong())
    _argIndex = 2
    for (_item: Long in missingAssetIds) {
      _stmt.bindLong(_argIndex, _item)
      _argIndex++
    }
    __db.beginTransaction()
    try {
      _stmt.executeUpdateDelete()
      __db.setTransactionSuccessful()
    } finally {
      __db.endTransaction()
    }
  }

  public companion object {
    @JvmStatic
    public fun getRequiredConverters(): List<Class<*>> = emptyList()
  }
}
