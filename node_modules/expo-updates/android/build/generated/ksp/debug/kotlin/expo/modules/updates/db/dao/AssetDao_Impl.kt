package expo.modules.updates.db.dao

import android.database.Cursor
import android.net.Uri
import androidx.room.EntityDeletionOrUpdateAdapter
import androidx.room.EntityInsertionAdapter
import androidx.room.RoomDatabase
import androidx.room.RoomSQLiteQuery
import androidx.room.RoomSQLiteQuery.Companion.acquire
import androidx.room.SharedSQLiteStatement
import androidx.room.util.getColumnIndexOrThrow
import androidx.room.util.query
import androidx.sqlite.db.SupportSQLiteStatement
import expo.modules.updates.db.Converters
import expo.modules.updates.db.entity.AssetEntity
import expo.modules.updates.db.entity.UpdateAssetEntity
import expo.modules.updates.db.entity.UpdateEntity
import java.lang.Class
import java.util.ArrayList
import java.util.Date
import java.util.UUID
import javax.`annotation`.processing.Generated
import kotlin.Boolean
import kotlin.ByteArray
import kotlin.Int
import kotlin.Long
import kotlin.String
import kotlin.Suppress
import kotlin.collections.List
import kotlin.collections.MutableList
import kotlin.jvm.JvmStatic
import org.json.JSONObject

@Generated(value = ["androidx.room.RoomProcessor"])
@Suppress(names = ["UNCHECKED_CAST", "DEPRECATION", "REDUNDANT_PROJECTION"])
public class AssetDao_Impl(
  __db: RoomDatabase,
) : AssetDao() {
  private val __db: RoomDatabase

  private val __insertionAdapterOfAssetEntity: EntityInsertionAdapter<AssetEntity>

  private val __converters: Converters = Converters()

  private val __insertionAdapterOfUpdateAssetEntity: EntityInsertionAdapter<UpdateAssetEntity>

  private val __updateAdapterOfAssetEntity: EntityDeletionOrUpdateAdapter<AssetEntity>

  private val __preparedStmtOfSetUpdateLaunchAssetInternal: SharedSQLiteStatement

  private val __preparedStmtOfMarkAllAssetsForDeletionInternal: SharedSQLiteStatement

  private val __preparedStmtOfUnMarkUsedAssetsFromDeletionInternal: SharedSQLiteStatement

  private val __preparedStmtOfUnMarkUsedLaunchAssetsFromDeletionInternal: SharedSQLiteStatement

  private val __preparedStmtOfUnMarkDuplicateUsedAssetsFromDeletionInternal: SharedSQLiteStatement

  private val __preparedStmtOfDeleteAssetsMarkedForDeletionInternal: SharedSQLiteStatement
  init {
    this.__db = __db
    this.__insertionAdapterOfAssetEntity = object : EntityInsertionAdapter<AssetEntity>(__db) {
      protected override fun createQuery(): String =
          "INSERT OR REPLACE INTO `assets` (`key`,`type`,`id`,`url`,`headers`,`extra_request_headers`,`metadata`,`download_time`,`relative_path`,`hash`,`hash_type`,`expected_hash`,`marked_for_deletion`) VALUES (?,?,nullif(?, 0),?,?,?,?,?,?,?,?,?,?)"

      protected override fun bind(statement: SupportSQLiteStatement, entity: AssetEntity) {
        val _tmpKey: String? = entity.key
        if (_tmpKey == null) {
          statement.bindNull(1)
        } else {
          statement.bindString(1, _tmpKey)
        }
        val _tmpType: String? = entity.type
        if (_tmpType == null) {
          statement.bindNull(2)
        } else {
          statement.bindString(2, _tmpType)
        }
        statement.bindLong(3, entity.id)
        val _tmpUrl: Uri? = entity.url
        val _tmp: String? = __converters.uriToString(_tmpUrl)
        if (_tmp == null) {
          statement.bindNull(4)
        } else {
          statement.bindString(4, _tmp)
        }
        val _tmpHeaders: JSONObject? = entity.headers
        val _tmp_1: String? = __converters.jsonObjectToString(_tmpHeaders)
        if (_tmp_1 == null) {
          statement.bindNull(5)
        } else {
          statement.bindString(5, _tmp_1)
        }
        val _tmpExtraRequestHeaders: JSONObject? = entity.extraRequestHeaders
        val _tmp_2: String? = __converters.jsonObjectToString(_tmpExtraRequestHeaders)
        if (_tmp_2 == null) {
          statement.bindNull(6)
        } else {
          statement.bindString(6, _tmp_2)
        }
        val _tmpMetadata: JSONObject? = entity.metadata
        val _tmp_3: String? = __converters.jsonObjectToString(_tmpMetadata)
        if (_tmp_3 == null) {
          statement.bindNull(7)
        } else {
          statement.bindString(7, _tmp_3)
        }
        val _tmpDownloadTime: Date? = entity.downloadTime
        val _tmp_4: Long? = __converters.dateToLong(_tmpDownloadTime)
        if (_tmp_4 == null) {
          statement.bindNull(8)
        } else {
          statement.bindLong(8, _tmp_4)
        }
        val _tmpRelativePath: String? = entity.relativePath
        if (_tmpRelativePath == null) {
          statement.bindNull(9)
        } else {
          statement.bindString(9, _tmpRelativePath)
        }
        val _tmpHash: ByteArray? = entity.hash
        if (_tmpHash == null) {
          statement.bindNull(10)
        } else {
          statement.bindBlob(10, _tmpHash)
        }
        val _tmp_5: Int = __converters.hashTypeToInt(entity.hashType)
        statement.bindLong(11, _tmp_5.toLong())
        val _tmpExpectedHash: String? = entity.expectedHash
        if (_tmpExpectedHash == null) {
          statement.bindNull(12)
        } else {
          statement.bindString(12, _tmpExpectedHash)
        }
        val _tmp_6: Int = if (entity.markedForDeletion) 1 else 0
        statement.bindLong(13, _tmp_6.toLong())
      }
    }
    this.__insertionAdapterOfUpdateAssetEntity = object :
        EntityInsertionAdapter<UpdateAssetEntity>(__db) {
      protected override fun createQuery(): String =
          "INSERT OR REPLACE INTO `updates_assets` (`update_id`,`asset_id`) VALUES (?,?)"

      protected override fun bind(statement: SupportSQLiteStatement, entity: UpdateAssetEntity) {
        val _tmp: ByteArray = __converters.uuidToBytes(entity.updateId)
        statement.bindBlob(1, _tmp)
        statement.bindLong(2, entity.assetId)
      }
    }
    this.__updateAdapterOfAssetEntity = object : EntityDeletionOrUpdateAdapter<AssetEntity>(__db) {
      protected override fun createQuery(): String =
          "UPDATE OR ABORT `assets` SET `key` = ?,`type` = ?,`id` = ?,`url` = ?,`headers` = ?,`extra_request_headers` = ?,`metadata` = ?,`download_time` = ?,`relative_path` = ?,`hash` = ?,`hash_type` = ?,`expected_hash` = ?,`marked_for_deletion` = ? WHERE `id` = ?"

      protected override fun bind(statement: SupportSQLiteStatement, entity: AssetEntity) {
        val _tmpKey: String? = entity.key
        if (_tmpKey == null) {
          statement.bindNull(1)
        } else {
          statement.bindString(1, _tmpKey)
        }
        val _tmpType: String? = entity.type
        if (_tmpType == null) {
          statement.bindNull(2)
        } else {
          statement.bindString(2, _tmpType)
        }
        statement.bindLong(3, entity.id)
        val _tmpUrl: Uri? = entity.url
        val _tmp: String? = __converters.uriToString(_tmpUrl)
        if (_tmp == null) {
          statement.bindNull(4)
        } else {
          statement.bindString(4, _tmp)
        }
        val _tmpHeaders: JSONObject? = entity.headers
        val _tmp_1: String? = __converters.jsonObjectToString(_tmpHeaders)
        if (_tmp_1 == null) {
          statement.bindNull(5)
        } else {
          statement.bindString(5, _tmp_1)
        }
        val _tmpExtraRequestHeaders: JSONObject? = entity.extraRequestHeaders
        val _tmp_2: String? = __converters.jsonObjectToString(_tmpExtraRequestHeaders)
        if (_tmp_2 == null) {
          statement.bindNull(6)
        } else {
          statement.bindString(6, _tmp_2)
        }
        val _tmpMetadata: JSONObject? = entity.metadata
        val _tmp_3: String? = __converters.jsonObjectToString(_tmpMetadata)
        if (_tmp_3 == null) {
          statement.bindNull(7)
        } else {
          statement.bindString(7, _tmp_3)
        }
        val _tmpDownloadTime: Date? = entity.downloadTime
        val _tmp_4: Long? = __converters.dateToLong(_tmpDownloadTime)
        if (_tmp_4 == null) {
          statement.bindNull(8)
        } else {
          statement.bindLong(8, _tmp_4)
        }
        val _tmpRelativePath: String? = entity.relativePath
        if (_tmpRelativePath == null) {
          statement.bindNull(9)
        } else {
          statement.bindString(9, _tmpRelativePath)
        }
        val _tmpHash: ByteArray? = entity.hash
        if (_tmpHash == null) {
          statement.bindNull(10)
        } else {
          statement.bindBlob(10, _tmpHash)
        }
        val _tmp_5: Int = __converters.hashTypeToInt(entity.hashType)
        statement.bindLong(11, _tmp_5.toLong())
        val _tmpExpectedHash: String? = entity.expectedHash
        if (_tmpExpectedHash == null) {
          statement.bindNull(12)
        } else {
          statement.bindString(12, _tmpExpectedHash)
        }
        val _tmp_6: Int = if (entity.markedForDeletion) 1 else 0
        statement.bindLong(13, _tmp_6.toLong())
        statement.bindLong(14, entity.id)
      }
    }
    this.__preparedStmtOfSetUpdateLaunchAssetInternal = object : SharedSQLiteStatement(__db) {
      public override fun createQuery(): String {
        val _query: String = "UPDATE updates SET launch_asset_id = ? WHERE id = ?;"
        return _query
      }
    }
    this.__preparedStmtOfMarkAllAssetsForDeletionInternal = object : SharedSQLiteStatement(__db) {
      public override fun createQuery(): String {
        val _query: String = "UPDATE assets SET marked_for_deletion = 1;"
        return _query
      }
    }
    this.__preparedStmtOfUnMarkUsedAssetsFromDeletionInternal = object : SharedSQLiteStatement(__db)
        {
      public override fun createQuery(): String {
        val _query: String =
            "UPDATE assets SET marked_for_deletion = 0 WHERE id IN ( SELECT asset_id FROM updates_assets INNER JOIN updates ON updates_assets.update_id = updates.id WHERE updates.keep);"
        return _query
      }
    }
    this.__preparedStmtOfUnMarkUsedLaunchAssetsFromDeletionInternal = object :
        SharedSQLiteStatement(__db) {
      public override fun createQuery(): String {
        val _query: String =
            "UPDATE assets SET marked_for_deletion = 0 WHERE id IN ( SELECT launch_asset_id FROM updates WHERE updates.keep);"
        return _query
      }
    }
    this.__preparedStmtOfUnMarkDuplicateUsedAssetsFromDeletionInternal = object :
        SharedSQLiteStatement(__db) {
      public override fun createQuery(): String {
        val _query: String =
            "UPDATE assets SET marked_for_deletion = 0 WHERE relative_path IN ( SELECT relative_path FROM assets WHERE marked_for_deletion = 0);"
        return _query
      }
    }
    this.__preparedStmtOfDeleteAssetsMarkedForDeletionInternal = object :
        SharedSQLiteStatement(__db) {
      public override fun createQuery(): String {
        val _query: String = "DELETE FROM assets WHERE marked_for_deletion = 1;"
        return _query
      }
    }
  }

  protected override fun insertAssetInternal(asset: AssetEntity): Long {
    __db.assertNotSuspendingTransaction()
    __db.beginTransaction()
    try {
      val _result: Long = __insertionAdapterOfAssetEntity.insertAndReturnId(asset)
      __db.setTransactionSuccessful()
      return _result
    } finally {
      __db.endTransaction()
    }
  }

  protected override fun insertUpdateAssetInternal(updateAsset: UpdateAssetEntity) {
    __db.assertNotSuspendingTransaction()
    __db.beginTransaction()
    try {
      __insertionAdapterOfUpdateAssetEntity.insert(updateAsset)
      __db.setTransactionSuccessful()
    } finally {
      __db.endTransaction()
    }
  }

  public override fun updateAsset(assetEntity: AssetEntity) {
    __db.assertNotSuspendingTransaction()
    __db.beginTransaction()
    try {
      __updateAdapterOfAssetEntity.handle(assetEntity)
      __db.setTransactionSuccessful()
    } finally {
      __db.endTransaction()
    }
  }

  public override fun insertAssets(assets: List<AssetEntity>, update: UpdateEntity) {
    __db.beginTransaction()
    try {
      super@AssetDao_Impl.insertAssets(assets, update)
      __db.setTransactionSuccessful()
    } finally {
      __db.endTransaction()
    }
  }

  public override fun addExistingAssetToUpdate(
    update: UpdateEntity,
    asset: AssetEntity,
    isLaunchAsset: Boolean,
  ): Boolean {
    __db.beginTransaction()
    try {
      val _result: Boolean
      _result = super@AssetDao_Impl.addExistingAssetToUpdate(update, asset, isLaunchAsset)
      __db.setTransactionSuccessful()
      return _result
    } finally {
      __db.endTransaction()
    }
  }

  public override fun deleteUnusedAssets(): List<AssetEntity> {
    __db.beginTransaction()
    try {
      val _result: List<AssetEntity>
      _result = super@AssetDao_Impl.deleteUnusedAssets()
      __db.setTransactionSuccessful()
      return _result
    } finally {
      __db.endTransaction()
    }
  }

  protected override fun setUpdateLaunchAssetInternal(assetId: Long, updateId: UUID) {
    __db.assertNotSuspendingTransaction()
    val _stmt: SupportSQLiteStatement = __preparedStmtOfSetUpdateLaunchAssetInternal.acquire()
    var _argIndex: Int = 1
    _stmt.bindLong(_argIndex, assetId)
    _argIndex = 2
    val _tmp: ByteArray = __converters.uuidToBytes(updateId)
    _stmt.bindBlob(_argIndex, _tmp)
    try {
      __db.beginTransaction()
      try {
        _stmt.executeUpdateDelete()
        __db.setTransactionSuccessful()
      } finally {
        __db.endTransaction()
      }
    } finally {
      __preparedStmtOfSetUpdateLaunchAssetInternal.release(_stmt)
    }
  }

  protected override fun markAllAssetsForDeletionInternal() {
    __db.assertNotSuspendingTransaction()
    val _stmt: SupportSQLiteStatement = __preparedStmtOfMarkAllAssetsForDeletionInternal.acquire()
    try {
      __db.beginTransaction()
      try {
        _stmt.executeUpdateDelete()
        __db.setTransactionSuccessful()
      } finally {
        __db.endTransaction()
      }
    } finally {
      __preparedStmtOfMarkAllAssetsForDeletionInternal.release(_stmt)
    }
  }

  protected override fun unMarkUsedAssetsFromDeletionInternal() {
    __db.assertNotSuspendingTransaction()
    val _stmt: SupportSQLiteStatement =
        __preparedStmtOfUnMarkUsedAssetsFromDeletionInternal.acquire()
    try {
      __db.beginTransaction()
      try {
        _stmt.executeUpdateDelete()
        __db.setTransactionSuccessful()
      } finally {
        __db.endTransaction()
      }
    } finally {
      __preparedStmtOfUnMarkUsedAssetsFromDeletionInternal.release(_stmt)
    }
  }

  protected override fun unMarkUsedLaunchAssetsFromDeletionInternal() {
    __db.assertNotSuspendingTransaction()
    val _stmt: SupportSQLiteStatement =
        __preparedStmtOfUnMarkUsedLaunchAssetsFromDeletionInternal.acquire()
    try {
      __db.beginTransaction()
      try {
        _stmt.executeUpdateDelete()
        __db.setTransactionSuccessful()
      } finally {
        __db.endTransaction()
      }
    } finally {
      __preparedStmtOfUnMarkUsedLaunchAssetsFromDeletionInternal.release(_stmt)
    }
  }

  protected override fun unMarkDuplicateUsedAssetsFromDeletionInternal() {
    __db.assertNotSuspendingTransaction()
    val _stmt: SupportSQLiteStatement =
        __preparedStmtOfUnMarkDuplicateUsedAssetsFromDeletionInternal.acquire()
    try {
      __db.beginTransaction()
      try {
        _stmt.executeUpdateDelete()
        __db.setTransactionSuccessful()
      } finally {
        __db.endTransaction()
      }
    } finally {
      __preparedStmtOfUnMarkDuplicateUsedAssetsFromDeletionInternal.release(_stmt)
    }
  }

  protected override fun deleteAssetsMarkedForDeletionInternal() {
    __db.assertNotSuspendingTransaction()
    val _stmt: SupportSQLiteStatement =
        __preparedStmtOfDeleteAssetsMarkedForDeletionInternal.acquire()
    try {
      __db.beginTransaction()
      try {
        _stmt.executeUpdateDelete()
        __db.setTransactionSuccessful()
      } finally {
        __db.endTransaction()
      }
    } finally {
      __preparedStmtOfDeleteAssetsMarkedForDeletionInternal.release(_stmt)
    }
  }

  protected override fun loadAssetsMarkedForDeletionInternal(): List<AssetEntity> {
    val _sql: String = "SELECT * FROM assets WHERE marked_for_deletion = 1;"
    val _statement: RoomSQLiteQuery = acquire(_sql, 0)
    __db.assertNotSuspendingTransaction()
    val _cursor: Cursor = query(__db, _statement, false, null)
    try {
      val _cursorIndexOfKey: Int = getColumnIndexOrThrow(_cursor, "key")
      val _cursorIndexOfType: Int = getColumnIndexOrThrow(_cursor, "type")
      val _cursorIndexOfId: Int = getColumnIndexOrThrow(_cursor, "id")
      val _cursorIndexOfUrl: Int = getColumnIndexOrThrow(_cursor, "url")
      val _cursorIndexOfHeaders: Int = getColumnIndexOrThrow(_cursor, "headers")
      val _cursorIndexOfExtraRequestHeaders: Int = getColumnIndexOrThrow(_cursor,
          "extra_request_headers")
      val _cursorIndexOfMetadata: Int = getColumnIndexOrThrow(_cursor, "metadata")
      val _cursorIndexOfDownloadTime: Int = getColumnIndexOrThrow(_cursor, "download_time")
      val _cursorIndexOfRelativePath: Int = getColumnIndexOrThrow(_cursor, "relative_path")
      val _cursorIndexOfHash: Int = getColumnIndexOrThrow(_cursor, "hash")
      val _cursorIndexOfHashType: Int = getColumnIndexOrThrow(_cursor, "hash_type")
      val _cursorIndexOfExpectedHash: Int = getColumnIndexOrThrow(_cursor, "expected_hash")
      val _cursorIndexOfMarkedForDeletion: Int = getColumnIndexOrThrow(_cursor,
          "marked_for_deletion")
      val _result: MutableList<AssetEntity> = ArrayList<AssetEntity>(_cursor.getCount())
      while (_cursor.moveToNext()) {
        val _item: AssetEntity
        val _tmpKey: String?
        if (_cursor.isNull(_cursorIndexOfKey)) {
          _tmpKey = null
        } else {
          _tmpKey = _cursor.getString(_cursorIndexOfKey)
        }
        val _tmpType: String?
        if (_cursor.isNull(_cursorIndexOfType)) {
          _tmpType = null
        } else {
          _tmpType = _cursor.getString(_cursorIndexOfType)
        }
        _item = AssetEntity(_tmpKey,_tmpType)
        _item.id = _cursor.getLong(_cursorIndexOfId)
        val _tmp: String?
        if (_cursor.isNull(_cursorIndexOfUrl)) {
          _tmp = null
        } else {
          _tmp = _cursor.getString(_cursorIndexOfUrl)
        }
        _item.url = __converters.stringToUri(_tmp)
        val _tmp_1: String?
        if (_cursor.isNull(_cursorIndexOfHeaders)) {
          _tmp_1 = null
        } else {
          _tmp_1 = _cursor.getString(_cursorIndexOfHeaders)
        }
        _item.headers = __converters.stringToJsonObject(_tmp_1)
        val _tmp_2: String?
        if (_cursor.isNull(_cursorIndexOfExtraRequestHeaders)) {
          _tmp_2 = null
        } else {
          _tmp_2 = _cursor.getString(_cursorIndexOfExtraRequestHeaders)
        }
        _item.extraRequestHeaders = __converters.stringToJsonObject(_tmp_2)
        val _tmp_3: String?
        if (_cursor.isNull(_cursorIndexOfMetadata)) {
          _tmp_3 = null
        } else {
          _tmp_3 = _cursor.getString(_cursorIndexOfMetadata)
        }
        _item.metadata = __converters.stringToJsonObject(_tmp_3)
        val _tmp_4: Long?
        if (_cursor.isNull(_cursorIndexOfDownloadTime)) {
          _tmp_4 = null
        } else {
          _tmp_4 = _cursor.getLong(_cursorIndexOfDownloadTime)
        }
        _item.downloadTime = __converters.longToDate(_tmp_4)
        if (_cursor.isNull(_cursorIndexOfRelativePath)) {
          _item.relativePath = null
        } else {
          _item.relativePath = _cursor.getString(_cursorIndexOfRelativePath)
        }
        if (_cursor.isNull(_cursorIndexOfHash)) {
          _item.hash = null
        } else {
          _item.hash = _cursor.getBlob(_cursorIndexOfHash)
        }
        val _tmp_5: Int
        _tmp_5 = _cursor.getInt(_cursorIndexOfHashType)
        _item.hashType = __converters.intToHashType(_tmp_5)
        if (_cursor.isNull(_cursorIndexOfExpectedHash)) {
          _item.expectedHash = null
        } else {
          _item.expectedHash = _cursor.getString(_cursorIndexOfExpectedHash)
        }
        val _tmp_6: Int
        _tmp_6 = _cursor.getInt(_cursorIndexOfMarkedForDeletion)
        _item.markedForDeletion = _tmp_6 != 0
        _result.add(_item)
      }
      return _result
    } finally {
      _cursor.close()
      _statement.release()
    }
  }

  protected override fun loadAssetWithKeyInternal(key: String?): List<AssetEntity> {
    val _sql: String = "SELECT * FROM assets WHERE `key` = ? LIMIT 1;"
    val _statement: RoomSQLiteQuery = acquire(_sql, 1)
    var _argIndex: Int = 1
    if (key == null) {
      _statement.bindNull(_argIndex)
    } else {
      _statement.bindString(_argIndex, key)
    }
    __db.assertNotSuspendingTransaction()
    val _cursor: Cursor = query(__db, _statement, false, null)
    try {
      val _cursorIndexOfKey: Int = getColumnIndexOrThrow(_cursor, "key")
      val _cursorIndexOfType: Int = getColumnIndexOrThrow(_cursor, "type")
      val _cursorIndexOfId: Int = getColumnIndexOrThrow(_cursor, "id")
      val _cursorIndexOfUrl: Int = getColumnIndexOrThrow(_cursor, "url")
      val _cursorIndexOfHeaders: Int = getColumnIndexOrThrow(_cursor, "headers")
      val _cursorIndexOfExtraRequestHeaders: Int = getColumnIndexOrThrow(_cursor,
          "extra_request_headers")
      val _cursorIndexOfMetadata: Int = getColumnIndexOrThrow(_cursor, "metadata")
      val _cursorIndexOfDownloadTime: Int = getColumnIndexOrThrow(_cursor, "download_time")
      val _cursorIndexOfRelativePath: Int = getColumnIndexOrThrow(_cursor, "relative_path")
      val _cursorIndexOfHash: Int = getColumnIndexOrThrow(_cursor, "hash")
      val _cursorIndexOfHashType: Int = getColumnIndexOrThrow(_cursor, "hash_type")
      val _cursorIndexOfExpectedHash: Int = getColumnIndexOrThrow(_cursor, "expected_hash")
      val _cursorIndexOfMarkedForDeletion: Int = getColumnIndexOrThrow(_cursor,
          "marked_for_deletion")
      val _result: MutableList<AssetEntity> = ArrayList<AssetEntity>(_cursor.getCount())
      while (_cursor.moveToNext()) {
        val _item: AssetEntity
        val _tmpKey: String?
        if (_cursor.isNull(_cursorIndexOfKey)) {
          _tmpKey = null
        } else {
          _tmpKey = _cursor.getString(_cursorIndexOfKey)
        }
        val _tmpType: String?
        if (_cursor.isNull(_cursorIndexOfType)) {
          _tmpType = null
        } else {
          _tmpType = _cursor.getString(_cursorIndexOfType)
        }
        _item = AssetEntity(_tmpKey,_tmpType)
        _item.id = _cursor.getLong(_cursorIndexOfId)
        val _tmp: String?
        if (_cursor.isNull(_cursorIndexOfUrl)) {
          _tmp = null
        } else {
          _tmp = _cursor.getString(_cursorIndexOfUrl)
        }
        _item.url = __converters.stringToUri(_tmp)
        val _tmp_1: String?
        if (_cursor.isNull(_cursorIndexOfHeaders)) {
          _tmp_1 = null
        } else {
          _tmp_1 = _cursor.getString(_cursorIndexOfHeaders)
        }
        _item.headers = __converters.stringToJsonObject(_tmp_1)
        val _tmp_2: String?
        if (_cursor.isNull(_cursorIndexOfExtraRequestHeaders)) {
          _tmp_2 = null
        } else {
          _tmp_2 = _cursor.getString(_cursorIndexOfExtraRequestHeaders)
        }
        _item.extraRequestHeaders = __converters.stringToJsonObject(_tmp_2)
        val _tmp_3: String?
        if (_cursor.isNull(_cursorIndexOfMetadata)) {
          _tmp_3 = null
        } else {
          _tmp_3 = _cursor.getString(_cursorIndexOfMetadata)
        }
        _item.metadata = __converters.stringToJsonObject(_tmp_3)
        val _tmp_4: Long?
        if (_cursor.isNull(_cursorIndexOfDownloadTime)) {
          _tmp_4 = null
        } else {
          _tmp_4 = _cursor.getLong(_cursorIndexOfDownloadTime)
        }
        _item.downloadTime = __converters.longToDate(_tmp_4)
        if (_cursor.isNull(_cursorIndexOfRelativePath)) {
          _item.relativePath = null
        } else {
          _item.relativePath = _cursor.getString(_cursorIndexOfRelativePath)
        }
        if (_cursor.isNull(_cursorIndexOfHash)) {
          _item.hash = null
        } else {
          _item.hash = _cursor.getBlob(_cursorIndexOfHash)
        }
        val _tmp_5: Int
        _tmp_5 = _cursor.getInt(_cursorIndexOfHashType)
        _item.hashType = __converters.intToHashType(_tmp_5)
        if (_cursor.isNull(_cursorIndexOfExpectedHash)) {
          _item.expectedHash = null
        } else {
          _item.expectedHash = _cursor.getString(_cursorIndexOfExpectedHash)
        }
        val _tmp_6: Int
        _tmp_6 = _cursor.getInt(_cursorIndexOfMarkedForDeletion)
        _item.markedForDeletion = _tmp_6 != 0
        _result.add(_item)
      }
      return _result
    } finally {
      _cursor.close()
      _statement.release()
    }
  }

  public override fun loadAllAssets(): List<AssetEntity> {
    val _sql: String = "SELECT * FROM assets;"
    val _statement: RoomSQLiteQuery = acquire(_sql, 0)
    __db.assertNotSuspendingTransaction()
    val _cursor: Cursor = query(__db, _statement, false, null)
    try {
      val _cursorIndexOfKey: Int = getColumnIndexOrThrow(_cursor, "key")
      val _cursorIndexOfType: Int = getColumnIndexOrThrow(_cursor, "type")
      val _cursorIndexOfId: Int = getColumnIndexOrThrow(_cursor, "id")
      val _cursorIndexOfUrl: Int = getColumnIndexOrThrow(_cursor, "url")
      val _cursorIndexOfHeaders: Int = getColumnIndexOrThrow(_cursor, "headers")
      val _cursorIndexOfExtraRequestHeaders: Int = getColumnIndexOrThrow(_cursor,
          "extra_request_headers")
      val _cursorIndexOfMetadata: Int = getColumnIndexOrThrow(_cursor, "metadata")
      val _cursorIndexOfDownloadTime: Int = getColumnIndexOrThrow(_cursor, "download_time")
      val _cursorIndexOfRelativePath: Int = getColumnIndexOrThrow(_cursor, "relative_path")
      val _cursorIndexOfHash: Int = getColumnIndexOrThrow(_cursor, "hash")
      val _cursorIndexOfHashType: Int = getColumnIndexOrThrow(_cursor, "hash_type")
      val _cursorIndexOfExpectedHash: Int = getColumnIndexOrThrow(_cursor, "expected_hash")
      val _cursorIndexOfMarkedForDeletion: Int = getColumnIndexOrThrow(_cursor,
          "marked_for_deletion")
      val _result: MutableList<AssetEntity> = ArrayList<AssetEntity>(_cursor.getCount())
      while (_cursor.moveToNext()) {
        val _item: AssetEntity
        val _tmpKey: String?
        if (_cursor.isNull(_cursorIndexOfKey)) {
          _tmpKey = null
        } else {
          _tmpKey = _cursor.getString(_cursorIndexOfKey)
        }
        val _tmpType: String?
        if (_cursor.isNull(_cursorIndexOfType)) {
          _tmpType = null
        } else {
          _tmpType = _cursor.getString(_cursorIndexOfType)
        }
        _item = AssetEntity(_tmpKey,_tmpType)
        _item.id = _cursor.getLong(_cursorIndexOfId)
        val _tmp: String?
        if (_cursor.isNull(_cursorIndexOfUrl)) {
          _tmp = null
        } else {
          _tmp = _cursor.getString(_cursorIndexOfUrl)
        }
        _item.url = __converters.stringToUri(_tmp)
        val _tmp_1: String?
        if (_cursor.isNull(_cursorIndexOfHeaders)) {
          _tmp_1 = null
        } else {
          _tmp_1 = _cursor.getString(_cursorIndexOfHeaders)
        }
        _item.headers = __converters.stringToJsonObject(_tmp_1)
        val _tmp_2: String?
        if (_cursor.isNull(_cursorIndexOfExtraRequestHeaders)) {
          _tmp_2 = null
        } else {
          _tmp_2 = _cursor.getString(_cursorIndexOfExtraRequestHeaders)
        }
        _item.extraRequestHeaders = __converters.stringToJsonObject(_tmp_2)
        val _tmp_3: String?
        if (_cursor.isNull(_cursorIndexOfMetadata)) {
          _tmp_3 = null
        } else {
          _tmp_3 = _cursor.getString(_cursorIndexOfMetadata)
        }
        _item.metadata = __converters.stringToJsonObject(_tmp_3)
        val _tmp_4: Long?
        if (_cursor.isNull(_cursorIndexOfDownloadTime)) {
          _tmp_4 = null
        } else {
          _tmp_4 = _cursor.getLong(_cursorIndexOfDownloadTime)
        }
        _item.downloadTime = __converters.longToDate(_tmp_4)
        if (_cursor.isNull(_cursorIndexOfRelativePath)) {
          _item.relativePath = null
        } else {
          _item.relativePath = _cursor.getString(_cursorIndexOfRelativePath)
        }
        if (_cursor.isNull(_cursorIndexOfHash)) {
          _item.hash = null
        } else {
          _item.hash = _cursor.getBlob(_cursorIndexOfHash)
        }
        val _tmp_5: Int
        _tmp_5 = _cursor.getInt(_cursorIndexOfHashType)
        _item.hashType = __converters.intToHashType(_tmp_5)
        if (_cursor.isNull(_cursorIndexOfExpectedHash)) {
          _item.expectedHash = null
        } else {
          _item.expectedHash = _cursor.getString(_cursorIndexOfExpectedHash)
        }
        val _tmp_6: Int
        _tmp_6 = _cursor.getInt(_cursorIndexOfMarkedForDeletion)
        _item.markedForDeletion = _tmp_6 != 0
        _result.add(_item)
      }
      return _result
    } finally {
      _cursor.close()
      _statement.release()
    }
  }

  public override fun loadAssetsForUpdate(id: UUID): List<AssetEntity> {
    val _sql: String =
        "SELECT assets.* FROM assets INNER JOIN updates_assets ON updates_assets.asset_id = assets.id INNER JOIN updates ON updates_assets.update_id = updates.id WHERE updates.id = ?;"
    val _statement: RoomSQLiteQuery = acquire(_sql, 1)
    var _argIndex: Int = 1
    val _tmp: ByteArray = __converters.uuidToBytes(id)
    _statement.bindBlob(_argIndex, _tmp)
    __db.assertNotSuspendingTransaction()
    val _cursor: Cursor = query(__db, _statement, false, null)
    try {
      val _cursorIndexOfKey: Int = getColumnIndexOrThrow(_cursor, "key")
      val _cursorIndexOfType: Int = getColumnIndexOrThrow(_cursor, "type")
      val _cursorIndexOfId: Int = getColumnIndexOrThrow(_cursor, "id")
      val _cursorIndexOfUrl: Int = getColumnIndexOrThrow(_cursor, "url")
      val _cursorIndexOfHeaders: Int = getColumnIndexOrThrow(_cursor, "headers")
      val _cursorIndexOfExtraRequestHeaders: Int = getColumnIndexOrThrow(_cursor,
          "extra_request_headers")
      val _cursorIndexOfMetadata: Int = getColumnIndexOrThrow(_cursor, "metadata")
      val _cursorIndexOfDownloadTime: Int = getColumnIndexOrThrow(_cursor, "download_time")
      val _cursorIndexOfRelativePath: Int = getColumnIndexOrThrow(_cursor, "relative_path")
      val _cursorIndexOfHash: Int = getColumnIndexOrThrow(_cursor, "hash")
      val _cursorIndexOfHashType: Int = getColumnIndexOrThrow(_cursor, "hash_type")
      val _cursorIndexOfExpectedHash: Int = getColumnIndexOrThrow(_cursor, "expected_hash")
      val _cursorIndexOfMarkedForDeletion: Int = getColumnIndexOrThrow(_cursor,
          "marked_for_deletion")
      val _result: MutableList<AssetEntity> = ArrayList<AssetEntity>(_cursor.getCount())
      while (_cursor.moveToNext()) {
        val _item: AssetEntity
        val _tmpKey: String?
        if (_cursor.isNull(_cursorIndexOfKey)) {
          _tmpKey = null
        } else {
          _tmpKey = _cursor.getString(_cursorIndexOfKey)
        }
        val _tmpType: String?
        if (_cursor.isNull(_cursorIndexOfType)) {
          _tmpType = null
        } else {
          _tmpType = _cursor.getString(_cursorIndexOfType)
        }
        _item = AssetEntity(_tmpKey,_tmpType)
        _item.id = _cursor.getLong(_cursorIndexOfId)
        val _tmp_1: String?
        if (_cursor.isNull(_cursorIndexOfUrl)) {
          _tmp_1 = null
        } else {
          _tmp_1 = _cursor.getString(_cursorIndexOfUrl)
        }
        _item.url = __converters.stringToUri(_tmp_1)
        val _tmp_2: String?
        if (_cursor.isNull(_cursorIndexOfHeaders)) {
          _tmp_2 = null
        } else {
          _tmp_2 = _cursor.getString(_cursorIndexOfHeaders)
        }
        _item.headers = __converters.stringToJsonObject(_tmp_2)
        val _tmp_3: String?
        if (_cursor.isNull(_cursorIndexOfExtraRequestHeaders)) {
          _tmp_3 = null
        } else {
          _tmp_3 = _cursor.getString(_cursorIndexOfExtraRequestHeaders)
        }
        _item.extraRequestHeaders = __converters.stringToJsonObject(_tmp_3)
        val _tmp_4: String?
        if (_cursor.isNull(_cursorIndexOfMetadata)) {
          _tmp_4 = null
        } else {
          _tmp_4 = _cursor.getString(_cursorIndexOfMetadata)
        }
        _item.metadata = __converters.stringToJsonObject(_tmp_4)
        val _tmp_5: Long?
        if (_cursor.isNull(_cursorIndexOfDownloadTime)) {
          _tmp_5 = null
        } else {
          _tmp_5 = _cursor.getLong(_cursorIndexOfDownloadTime)
        }
        _item.downloadTime = __converters.longToDate(_tmp_5)
        if (_cursor.isNull(_cursorIndexOfRelativePath)) {
          _item.relativePath = null
        } else {
          _item.relativePath = _cursor.getString(_cursorIndexOfRelativePath)
        }
        if (_cursor.isNull(_cursorIndexOfHash)) {
          _item.hash = null
        } else {
          _item.hash = _cursor.getBlob(_cursorIndexOfHash)
        }
        val _tmp_6: Int
        _tmp_6 = _cursor.getInt(_cursorIndexOfHashType)
        _item.hashType = __converters.intToHashType(_tmp_6)
        if (_cursor.isNull(_cursorIndexOfExpectedHash)) {
          _item.expectedHash = null
        } else {
          _item.expectedHash = _cursor.getString(_cursorIndexOfExpectedHash)
        }
        val _tmp_7: Int
        _tmp_7 = _cursor.getInt(_cursorIndexOfMarkedForDeletion)
        _item.markedForDeletion = _tmp_7 != 0
        _result.add(_item)
      }
      return _result
    } finally {
      _cursor.close()
      _statement.release()
    }
  }

  public companion object {
    @JvmStatic
    public fun getRequiredConverters(): List<Class<*>> = emptyList()
  }
}
