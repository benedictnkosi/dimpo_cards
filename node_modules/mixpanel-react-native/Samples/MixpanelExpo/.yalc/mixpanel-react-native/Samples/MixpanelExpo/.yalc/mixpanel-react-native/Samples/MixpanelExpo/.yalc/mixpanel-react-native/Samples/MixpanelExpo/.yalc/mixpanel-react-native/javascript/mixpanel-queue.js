import { MixpanelLogger } from "./mixpanel-logger";
import { MixpanelPersistent } from "./mixpanel-persistent";
import { MixpanelType } from "./mixpanel-constants";

export const MixpanelQueueManager = (() => {
  let _queues = {};
  let mixpanelPersistent;

  const getPersistent = () => {
    if (!mixpanelPersistent) {
      mixpanelPersistent = MixpanelPersistent.getInstance();
    }
    return mixpanelPersistent;
  };

  const initialize = async (token, type) => {
    if (!_queues[token] || !_queues[token][type]) {
      const queue = await getPersistent().loadQueue(token, type);
      _queues[token] = {
        ..._queues[token],
        [type]: queue,
      };
    }
  };

  const updateQueueInStorage = async (token, type) => {
    if (!_queues[token] || !_queues[token][type]) {
      return;
    }
    await getPersistent().saveQueue(token, type, _queues[token][type]);
  };

  const enqueue = async (token, type, data) => {
    MixpanelLogger.log(
      token,
      `Enqueuing data for token: ${token}, type: ${type}`
    );
    if (!_queues[token] || !_queues[token][type]) {
      _queues[token] = {
        ..._queues[token],
        [type]: [],
      };
    }
    _queues[token][type].push(data);
    await updateQueueInStorage(token, type);
  };

  const getQueue = (token, type) => {
    MixpanelLogger.log(
      token,
      `Getting queue for token: ${token}, type: ${type}`
    );
    if (!_queues[token] || !_queues[token][type]) {
      return [];
    }
    const isUserAndUnidentified =
      type === MixpanelType.USER && !getPersistent().isIdentified(token);
    MixpanelLogger.log(`isUserAndUnidentified: ${isUserAndUnidentified}`);
    return [..._queues[token][type]];
  };

  const spliceQueue = async (token, type, start, deleteCount) => {
    if (!_queues[token] || !_queues[token][type]) {
      return;
    }
    _queues[token][type].splice(start, deleteCount);
    await updateQueueInStorage(token, type);
  };

  const clearQueue = async (token, type) => {
    if (!_queues[token] || !_queues[token][type]) {
      return;
    }
    _queues[token][type] = [];
    await updateQueueInStorage(token, type);
  };

  /**
   * Ensures all records in the USER queue for the given token have the correct
   * $distinct_id, $device_id, and $user_id fields set (if missing or null).
   * Returns the updated queue.
   */
  const identifyUserQueue = async (token) => {
    const persistent = getPersistent();
    // Retrieve identity values from MixpanelPersistent
    const distinctId = persistent.getDistinctId(token);
    const deviceId = persistent.getDeviceId(token);
    const userId = persistent.getUserId(token);

    // Defensive: check for valid queue
    if (!_queues[token] || !_queues[token][MixpanelType.USER]) {
      return [];
    }
    let queue = _queues[token][MixpanelType.USER];
    let changed = false;

    // Update records in-place only if needed
    queue = queue.map((record) => {
      let updated = { ...record };
      let modified = false;

      if (distinctId != null) {
        updated.$distinct_id = distinctId;
        modified = true;
      }
      if (deviceId != null) {
        updated.$device_id = deviceId;
        modified = true;
      }
      if (userId != null) {
        updated.$user_id = userId;
        modified = true;
      }
      if (modified) changed = true;
      return updated;
    });

    // If any changes, save the queue
    if (changed) {
      _queues[token][MixpanelType.USER] = queue;
      await persistent.saveQueue(token, MixpanelType.USER, queue);
    }
    return queue;
  };

  return {
    initialize,
    enqueue,
    getQueue,
    spliceQueue,
    clearQueue,
    identifyUserQueue,
  };
})();
