---
applyTo: "ios/**/*.swift,android/**/*.java,**/*Native*.js"
---

# Native Bridge Implementation Guidelines

Extends [core instructions](../copilot-instructions.md) with React Native bridge-specific patterns.

## iOS Swift Requirements

### Method Declaration
```swift
@objc
func methodName(_ token: String,
                parameter: String,
                resolver resolve: RCTPromiseResolveBlock,
                rejecter reject: RCTPromiseRejectBlock) -> Void {
    let instance = MixpanelReactNative.getMixpanelInstance(token)
    guard let instance = instance else {
        reject("Instance Error", "Failed to get Mixpanel instance", nil)
        return
    }
    
    // Type conversion using MixpanelTypeHandler
    let processedValue = MixpanelTypeHandler.processProperty(value: value)
    
    // Call native SDK method
    instance.nativeMethod(parameter: processedValue)
    resolve(nil)
}
```

### Required Patterns
- **@objc decorator**: Every bridge method must have @objc
- **Promise pattern**: Use resolver/rejecter for async operations
- **Instance management**: Always get instance by token
- **Error handling**: Guard against missing instances
- **Type conversion**: Use MixpanelTypeHandler for React Native → Swift types

## Android Java Requirements

### Method Declaration
```java
@ReactMethod
public void methodName(final String token, 
                      String parameter, 
                      Dynamic value, 
                      Promise promise) throws JSONException {
    MixpanelAPI instance = MixpanelAPI.getInstance(this.mReactContext, token, true);
    if (instance == null) {
        promise.reject("Instance Error", "Failed to get Mixpanel instance");
        return;
    }
    
    synchronized (instance) {
        Object processedValue = ReactNativeHelper.dynamicToObject(value);
        instance.nativeMethod(parameter, processedValue);
        promise.resolve(null);
    }
}
```

### Required Patterns
- **@ReactMethod annotation**: Every bridge method must have annotation
- **Thread safety**: Use synchronized (instance) for all operations
- **Type conversion**: Use ReactNativeHelper for React Native → Java types
- **Promise pattern**: Handle async operations with Promise parameter
- **Error handling**: Check for null instances

## Bridge Integration

### JavaScript Native Module Interface
```javascript
// Check availability before calling
if (MixpanelReactNative && MixpanelReactNative.methodName) {
  return MixpanelReactNative.methodName(token, parameter);
} else {
  console.warn("Native method not available, falling back to JS implementation");
  return jsImplementation(token, parameter);
}

// Error handling for native calls
try {
  await MixpanelReactNative.methodName(token, parameter);
} catch (error) {
  MixpanelLogger.error(token, `Native method failed: ${error.message}`);
  return jsImplementation(token, parameter);
}
```

### Testing Native Modules
```javascript
// Mock native module in tests
jest.doMock("react-native", () => ({
  NativeModules: {
    MixpanelReactNative: {
      methodName: jest.fn().mockResolvedValue(undefined),
      // Mock ALL native methods
    },
  },
}));

// Test native implementation calls
expect(MixpanelReactNative.methodName).toHaveBeenCalledWith(
  'test-token',
  'parameter',
  expect.objectContaining({})
);
```

## Platform-Specific Considerations

### iOS-Specific Features
- Background flushing support via `setFlushOnBackground`
- Use iOS-specific optimizations where available
- Handle iOS lifecycle events appropriately

### Android Limitations
- No background flushing support
- Require thread synchronization for all operations
- Handle Android-specific memory considerations

### Performance Optimization
- Minimize bridge calls by batching operations
- Use native queue management when available
- Leverage platform-specific features efficiently