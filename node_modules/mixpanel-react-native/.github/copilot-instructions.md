# Essential Coding Standards for Mixpanel React Native

> Critical patterns preventing errors. Every instruction has proven impact.

## ðŸ”’ Security & Validation

**ALWAYS validate inputs with Helper classes**:
```javascript
if (!StringHelper.isValid(eventName)) {
  StringHelper.raiseError(PARAMS.EVENT_NAME);
}
if (!ObjectHelper.isValidOrUndefined(properties)) {
  ObjectHelper.raiseError(PARAMS.PROPERTIES);
}
```

**ALWAYS check opt-out before operations**:
```javascript
if (this.mixpanelPersistent.getOptedOut(token)) {
  MixpanelLogger.log(token, `User opted out, skipping ${operation}`);
  return;
}
```

## âš¡ Error Handling Patterns

**Storage operations - Silent failure with defaults**:
```javascript
async getItem(key) {
  try {
    return await this.storage.getItem(key);
  } catch {
    MixpanelLogger.error("error getting item from storage");
    return null; // ALWAYS return usable default
  }
}
```

**Network operations - Retry with exponential backoff**:
```javascript
const sendRequest = async ({...params, retryCount = 0}) => {
  try {
    return await fetch(url, options);
  } catch (error) {
    if (retryCount < maxRetries) {
      const backoff = Math.min(2 ** retryCount * 2000, 60000);
      await new Promise(resolve => setTimeout(resolve, backoff));
      return sendRequest({...params, retryCount: retryCount + 1});
    }
    throw error;
  }
};
```

**UUID generation - Expo fallback**:
```javascript
try {
  deviceId = randomUUID(); // expo-crypto
} catch (e) {
  deviceId = uuid.v4();    // uuid package
}
```

## ðŸ—ï¸ Architecture Rules

**Token-based multi-tenancy (MANDATORY)**:
```javascript
// EVERY operation includes token as first parameter
const track = async (token, eventName, properties) => { /* ... */ };
const flush = async (token) => { /* ... */ };

// ALL storage keys are token-scoped
const key = `MIXPANEL_${token}_${type}_${field}`;
```

**Dual implementation routing**:
```javascript
if (useNative && MixpanelReactNative) {
  this.mixpanelImpl = MixpanelReactNative;
} else {
  if (useNative) {
    console.warn("MixpanelReactNative not available; using JavaScript mode...");
  }
  this.mixpanelImpl = new MixpanelMain(token, trackAutomaticEvents, storage);
}
```

**Queue-based processing**:
```javascript
const enqueue = async (token, type, data) => {
  _queues[token][type].push(data);
  await updateQueueInStorage(token, type);
  
  if (_queues[token][type].length >= batchSize) {
    processBatch(token, type);
  }
};
```

## ðŸ“± Native Module Patterns

**iOS Swift**:
```swift
@objc
func methodName(_ token: String,
                parameter: String,
                resolver resolve: RCTPromiseResolveBlock,
                rejecter reject: RCTPromiseRejectBlock) -> Void {
    guard let instance = MixpanelReactNative.getMixpanelInstance(token) else {
        reject("Instance Error", "Failed to get Mixpanel instance", nil)
        return
    }
    instance.nativeMethod(parameter: parameter)
    resolve(nil)
}
```

**Android Java**:
```java
@ReactMethod
public void methodName(String token, String parameter, Promise promise) {
    MixpanelAPI instance = MixpanelAPI.getInstance(mReactContext, token, true);
    if (instance == null) {
        promise.reject("Instance Error", "Failed to get Mixpanel instance");
        return;
    }
    synchronized (instance) {
        instance.nativeMethod(parameter);
        promise.resolve(null);
    }
}
```

## ðŸ§¹ Data Handling

**Conditional property inclusion - prevent null values**:
```javascript
const profileData = {
  $token: token,
  $time: Date.now(),
  ...action,
  ...(distinctId != null && { $distinct_id: distinctId }),
  ...(deviceId != null && { $device_id: deviceId }),
  ...(userId != null && { $user_id: userId }),
};
```

**Storage module resolution**:
```javascript
const storageModule = require("@react-native-async-storage/async-storage");
if (storageModule.default) {
  this.storage = storageModule.default;
} else {
  this.storage = storageModule;
}
```

## ðŸ§ª Testing Requirements

**Test both modes for every feature**:
```javascript
describe('Feature', () => {
  it('Native mode', () => {
    mixpanel = new Mixpanel('token', true, true); // Force native
    mixpanel.track('Event', {prop: 'value'});
    expect(MixpanelReactNative.track).toHaveBeenCalled();
  });

  it('JavaScript mode', () => {
    mixpanel = new Mixpanel('token', true, false); // Force JS
    mixpanel.track('Event', {prop: 'value'});
    expect(MixpanelQueueManager.enqueue).toHaveBeenCalled();
  });
});
```

## ðŸ“‹ Quick Reference

### Naming
- Files: `mixpanel-{feature}.js` (kebab-case)
- Variables: `camelCase`
- Constants: `SCREAMING_SNAKE_CASE`
- Functions: verb-first (`initialize`, `track`, `flush`)

### Key Files
- `index.js` - Public API with validation
- `javascript/mixpanel-main.js` - JS implementation
- `javascript/mixpanel-core.js` - Shared logic
- `ios/MixpanelReactNative.swift` - iOS native
- `android/.../MixpanelReactNativeModule.java` - Android native

### Critical Patterns
- Token as first parameter everywhere
- Validate all inputs with Helper classes
- Silent failure for infrastructure errors
- Check opt-out before any operation
- Test both native and JS modes
- Log with token context and [Mixpanel] prefix