---
mode: 'agent'
tools: ['codebase', 'terminal']
description: 'Systematic debugging approach for Mixpanel React Native issues'
---

Debug the issue: "${input:issueDescription}" in the Mixpanel React Native library.

## Systematic Debugging Workflow

Follow this systematic approach to identify and resolve the issue:

### 1. Determine Implementation Mode (FIRST STEP)
```javascript
// Add this debug code to identify which implementation is active
const debugImplementationMode = () => {
  console.log('=== Mixpanel Debug Info ===');
  console.log('Native module available:', !!NativeModules.MixpanelReactNative);
  console.log('Implementation type:', 
    mixpanel.mixpanelImpl === MixpanelReactNative ? 'Native' : 'JavaScript');
  console.log('Platform:', Platform.OS);
  console.log('==============================');
};
```

### 2. Enable Comprehensive Logging
```javascript
// Enable logging for debugging session
mixpanel.setLoggingEnabled(true);

// Verify logging is working
console.log('Logging enabled:', mixpanel.config?.getLoggingEnabled?.(token));

// Look for [Mixpanel] prefix in console output
```

### 3. Check Basic Configuration
```javascript
const debugConfiguration = async () => {
  console.log('=== Configuration Debug ===');
  console.log('Token:', mixpanel.token);
  console.log('Track automatic events:', mixpanel.trackAutomaticEvents);
  console.log('Opted out:', await mixpanel.hasOptedOutTracking());
  console.log('Distinct ID:', await mixpanel.getDistinctId());
  console.log('Device ID:', await mixpanel.getDeviceId());
  console.log('Super properties:', await mixpanel.getSuperProperties());
  console.log('==============================');
};
```

## Native Mode Debugging

### "MixpanelReactNative not available" Issues

#### iOS Troubleshooting
```bash
# Clean and reinstall pods
cd ios
pod install --repo-update
cd ..

# Clean and rebuild
npx react-native run-ios --reset-cache
```

#### Android Troubleshooting
```bash
# Clean and rebuild
cd android
./gradlew clean
./gradlew build
cd ..

# Verify autolinking
npx react-native config

# Clean and rebuild
npx react-native run-android --reset-cache
```

### Native Method Call Failures
```javascript
// Test native bridge directly
const testNativeBridge = async () => {
  try {
    await NativeModules.MixpanelReactNative?.initialize?.(
      'test-token', 
      true, 
      false, 
      {}, 
      'https://api.mixpanel.com',
      false
    );
    console.log('‚úÖ Native bridge working');
  } catch (error) {
    console.error('‚ùå Native bridge error:', error);
    console.log('Available methods:', Object.keys(NativeModules.MixpanelReactNative || {}));
  }
};
```

### Platform-Specific Issues
```javascript
// iOS-specific debugging
const debugiOS = () => {
  if (Platform.OS === 'ios') {
    console.log('=== iOS Debug ===');
    
    try {
      mixpanel.setFlushOnBackground(true);
      console.log('‚úÖ iOS setFlushOnBackground working');
    } catch (error) {
      console.error('‚ùå iOS method error:', error);
    }
  }
};

// Android-specific debugging
const debugAndroid = () => {
  if (Platform.OS === 'android') {
    console.log('=== Android Debug ===');
    console.log('Note: setFlushOnBackground not supported on Android');
    console.log('Instance management: Thread-safe synchronized');
  }
};
```

## JavaScript Mode Debugging

### Events Not Being Tracked
```javascript
const debugEventTracking = async () => {
  console.log('=== Event Tracking Debug ===');
  
  // Check opt-out status FIRST
  const optedOut = await mixpanel.hasOptedOutTracking();
  console.log('Opted out:', optedOut);
  
  if (optedOut) {
    console.log('‚ùå User has opted out - events will not be tracked');
    return;
  }
  
  // Test queue addition
  mixpanel.track('Debug Event', { debug: true, timestamp: Date.now() });
  
  if (mixpanel.mixpanelImpl !== MixpanelReactNative) {
    console.log('‚úÖ JavaScript mode - event should be queued');
  }
  
  console.log('=============================');
};
```

### Queue Not Processing
```javascript
const debugQueueProcessing = () => {
  console.log('=== Queue Processing Debug ===');
  
  // Check flush configuration
  const config = mixpanel.mixpanelImpl?.config;
  if (config) {
    console.log('Flush interval:', config.getFlushInterval?.(mixpanel.token));
    console.log('Batch size:', config.getFlushBatchSize?.(mixpanel.token));
    console.log('Server URL:', config.getServerURL?.(mixpanel.token));
  }
  
  // Manual flush test
  console.log('Triggering manual flush...');
  mixpanel.flush();
  
  console.log('===============================');
};
```

### Storage Problems
```javascript
const debugStorage = async () => {
  console.log('=== Storage Debug ===');
  
  try {
    // Test AsyncStorage directly
    await AsyncStorage.setItem('mixpanel_test_key', 'test_value');
    const value = await AsyncStorage.getItem('mixpanel_test_key');
    console.log('‚úÖ AsyncStorage working:', value === 'test_value');
    await AsyncStorage.removeItem('mixpanel_test_key');
  } catch (error) {
    console.error('‚ùå AsyncStorage error:', error);
    console.log('Falling back to in-memory storage');
  }
  
  // Test Mixpanel storage
  try {
    await mixpanel.registerSuperProperties({ debug_test: true });
    const newProps = await mixpanel.getSuperProperties();
    console.log('‚úÖ Mixpanel storage working:', newProps.debug_test === true);
  } catch (error) {
    console.error('‚ùå Mixpanel storage error:', error);
  }
  
  console.log('===================');
};
```

## Network Debugging

### Test Network Connectivity
```javascript
const debugNetwork = async () => {
  console.log('=== Network Debug ===');
  
  try {
    const response = await fetch('https://api.mixpanel.com/track/', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: 'data=' + encodeURIComponent(JSON.stringify([{
        event: 'Debug Test',
        properties: {
          token: mixpanel.token,
          time: Date.now(),
          distinct_id: 'debug-user'
        }
      }]))
    });
    
    console.log('Network response status:', response.status);
    const result = await response.json();
    console.log('Network response body:', result);
    
    if (response.status === 200 && result === 1) {
      console.log('‚úÖ Network connectivity working');
    } else {
      console.log('‚ùå Network issue detected');
    }
  } catch (error) {
    console.error('‚ùå Network error:', error);
  }
  
  console.log('===================');
};
```

## Common Error Scenarios

### Silent Failures
```javascript
const debugSilentFailures = () => {
  console.log('=== Silent Failure Debug ===');
  
  // Test problematic data types
  const testCases = [
    { name: 'Circular reference', data: {} },
    { name: 'Function property', data: { fn: () => {} } },
    { name: 'Symbol property', data: { sym: Symbol('test') } },
    { name: 'Large object', data: { large: 'x'.repeat(10000) } },
  ];
  
  // Create circular reference
  testCases[0].data.self = testCases[0].data;
  
  testCases.forEach(testCase => {
    console.log(`Testing: ${testCase.name}`);
    try {
      JSON.stringify(testCase.data);
      console.log(`‚úÖ ${testCase.name} - serializable`);
      
      mixpanel.track(`Test ${testCase.name}`, testCase.data);
      console.log(`‚úÖ ${testCase.name} - tracked successfully`);
    } catch (error) {
      console.error(`‚ùå ${testCase.name} - error:`, error.message);
    }
  });
  
  console.log('============================');
};
```

### Memory Leaks
```javascript
const debugMemoryUsage = async () => {
  console.log('=== Memory Usage Debug ===');
  
  const initialMemory = performance.memory?.usedJSHeapSize || 'Unknown';
  console.log('Initial memory:', initialMemory);
  
  // Create multiple instances
  const instances = [];
  for (let i = 0; i < 10; i++) {
    const instance = new Mixpanel(`test-token-${i}`, true);
    await instance.init();
    instances.push(instance);
  }
  
  const afterCreateMemory = performance.memory?.usedJSHeapSize || 'Unknown';
  console.log('Memory after creating 10 instances:', afterCreateMemory);
  
  // Reset instances
  for (const instance of instances) {
    await instance.reset();
  }
  
  const afterResetMemory = performance.memory?.usedJSHeapSize || 'Unknown';
  console.log('Memory after reset:', afterResetMemory);
  
  console.log('==========================');
};
```

## Complete Health Check

```javascript
// Run comprehensive diagnostic
const runCompleteHealthCheck = async () => {
  console.log('üîç Starting Mixpanel Health Check...\n');
  
  try {
    // 1. Implementation mode
    debugImplementationMode();
    
    // 2. Configuration
    await debugConfiguration();
    
    // 3. Storage
    await debugStorage();
    
    // 4. Network
    await debugNetwork();
    
    // 5. Event tracking
    await debugEventTracking();
    
    // 6. Platform-specific
    if (Platform.OS === 'ios') {
      debugiOS();
    } else if (Platform.OS === 'android') {
      debugAndroid();
    }
    
    console.log('‚úÖ Health check completed');
  } catch (error) {
    console.error('‚ùå Health check failed:', error);
  }
};
```

## Debugging Checklist

### Basic Issues
- [ ] Verify implementation mode (native vs JavaScript)
- [ ] Check logging is enabled
- [ ] Confirm token is valid
- [ ] Verify user hasn't opted out
- [ ] Test basic connectivity

### Native Mode Issues
- [ ] Run `pod install` (iOS) or gradle clean/build (Android)
- [ ] Verify autolinking configuration
- [ ] Check native module availability
- [ ] Test native bridge directly

### JavaScript Mode Issues
- [ ] Check AsyncStorage availability
- [ ] Verify queue processing
- [ ] Test manual flush
- [ ] Check storage persistence

### Performance Issues
- [ ] Monitor memory usage
- [ ] Check for circular references
- [ ] Verify batch sizes
- [ ] Test under load

Reference our debugging guide: `claude/workflows/03-debugging-issues.md`
Use our standard patterns: `.github/copilot-instructions.md`