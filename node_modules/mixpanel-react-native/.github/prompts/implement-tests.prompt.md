---
mode: 'agent'
tools: ['codebase', 'terminal']
description: 'Implement comprehensive tests for dual-implementation features'
---

Implement comprehensive tests for the feature: "${input:featureName}" in the Mixpanel React Native library.

## Testing Workflow

Create complete test coverage following our dual-implementation testing patterns:

### 1. Test File Setup
Create test file: `__tests__/${input:featureName}.test.js`

```javascript
import { jest } from "@jest/globals";

// Import required mocks (automatically loaded from jest_setup.js)
const { MixpanelQueueManager } = require("mixpanel-react-native/javascript/mixpanel-queue");
const { MixpanelNetwork } = require("mixpanel-react-native/javascript/mixpanel-network");

describe('${input:featureName} Tests', () => {
  let mixpanel;
  
  beforeEach(() => {
    jest.clearAllMocks();
    MixpanelQueueManager._queues = {};
  });

  afterEach(() => {
    jest.clearAllTimers();
  });
  
  // Test sections will be added below
});
```

### 2. Input Validation Tests (MANDATORY)
```javascript
describe('Input Validation', () => {
  beforeEach(() => {
    mixpanel = new Mixpanel('test-token', true);
  });

  // Test ALL invalid string inputs
  const invalidStrings = ['', null, undefined, '   ', 123, {}, [], Symbol('test')];
  
  invalidStrings.forEach((invalid) => {
    it(`should reject invalid string parameter: ${JSON.stringify(invalid)}`, () => {
      expect(() => {
        mixpanel.${input:featureName}(invalid, {});
      }).toThrow('parameter is not a valid string');
    });
  });

  // Test ALL invalid object inputs
  const invalidObjects = ['string', 123, true, () => {}, Symbol('test')];
  
  invalidObjects.forEach((invalid) => {
    it(`should reject invalid object parameter: ${typeof invalid}`, () => {
      expect(() => {
        mixpanel.${input:featureName}('valid', invalid);
      }).toThrow('properties is not a valid json object');
    });
  });

  // Test edge cases
  it('should allow null and undefined optional parameters', () => {
    expect(() => {
      mixpanel.${input:featureName}('valid', null);
      mixpanel.${input:featureName}('valid', undefined);
    }).not.toThrow();
  });

  it('should reject whitespace-only strings', () => {
    expect(() => {
      mixpanel.${input:featureName}('   ', {});
    }).toThrow('parameter is not a valid string');
  });
});
```

### 3. Native Mode Tests (REQUIRED)
```javascript
describe('Native Mode', () => {
  beforeEach(() => {
    // Force native mode
    mixpanel = new Mixpanel('test-token', true, true);
  });

  it('should call native implementation', () => {
    const parameter = 'test_parameter';
    const properties = { testProp: 'testValue' };

    mixpanel.${input:featureName}(parameter, properties);

    expect(MixpanelReactNative.${input:featureName}).toHaveBeenCalledWith(
      'test-token',
      parameter,
      expect.objectContaining({
        ...properties,
        // Should include metadata
        mp_lib: 'react-native',
        $lib_version: expect.any(String)
      })
    );
  });

  it('should handle native implementation promises', async () => {
    MixpanelReactNative.${input:featureName}.mockResolvedValue();

    await expect(
      mixpanel.${input:featureName}('parameter', {})
    ).resolves.toBeUndefined();

    expect(MixpanelReactNative.${input:featureName}).toHaveBeenCalledWith(
      'test-token',
      'parameter',
      expect.any(Object)
    );
  });

  it('should handle native implementation errors', async () => {
    const error = new Error('Native error');
    MixpanelReactNative.${input:featureName}.mockRejectedValue(error);

    await expect(
      mixpanel.${input:featureName}('parameter', {})
    ).rejects.toThrow('Native error');
  });

  it('should verify implementation type', () => {
    expect(mixpanel.mixpanelImpl).toBe(MixpanelReactNative);
  });
});
```

### 4. JavaScript Mode Tests (REQUIRED)
```javascript
describe('JavaScript Mode', () => {
  beforeEach(() => {
    // Force JavaScript mode
    mixpanel = new Mixpanel('test-token', true, false);
  });

  it('should use JavaScript implementation', () => {
    expect(mixpanel.mixpanelImpl).toBeInstanceOf(MixpanelMain);
    expect(mixpanel.mixpanelImpl).not.toBe(MixpanelReactNative);
  });

  it('should queue events for batch processing', async () => {
    const parameter = 'test_parameter';
    const properties = { prop: 'value' };

    mixpanel.${input:featureName}(parameter, properties);

    // Verify event was added to queue
    expect(MixpanelQueueManager.enqueue).toHaveBeenCalledWith(
      'test-token',
      MixpanelType.EVENTS,
      expect.objectContaining({
        event: parameter,
        properties: expect.objectContaining(properties)
      })
    );
  });

  it('should respect opt-out status', async () => {
    // Mock opt-out status
    const mockPersistent = {
      getOptedOut: jest.fn().mockReturnValue(true)
    };
    MixpanelPersistent.getInstance.mockReturnValue(mockPersistent);

    mixpanel.${input:featureName}('parameter', {});

    // Should not queue event when opted out
    expect(MixpanelQueueManager.enqueue).not.toHaveBeenCalled();
  });

  it('should enrich events with complete metadata', async () => {
    // Set up context
    await mixpanel.identify('user123');
    await mixpanel.registerSuperProperties({ segment: 'premium' });

    mixpanel.${input:featureName}('parameter', { amount: 99.99 });

    expect(MixpanelQueueManager.enqueue).toHaveBeenCalledWith(
      'test-token',
      MixpanelType.EVENTS,
      expect.objectContaining({
        event: 'parameter',
        properties: expect.objectContaining({
          // Event properties
          amount: 99.99,
          // Super properties
          segment: 'premium',
          // Identity properties
          distinct_id: 'user123',
          // Metadata
          mp_lib: 'react-native',
          $lib_version: expect.any(String),
          // Session metadata
          $mp_metadata: expect.objectContaining({
            $mp_session_id: expect.any(String),
            $mp_event_id: expect.any(String)
          })
        })
      })
    );
  });
});
```

### 5. Error Handling Tests (CRITICAL)
```javascript
describe('Error Handling', () => {
  beforeEach(() => {
    mixpanel = new Mixpanel('test-token', true, false);
  });

  it('should handle storage failures gracefully', async () => {
    const storageError = new Error('Storage unavailable');
    AsyncStorage.setItem.mockRejectedValue(storageError);

    // Should not throw error
    await expect(
      mixpanel.${input:featureName}('parameter', { prop: 'value' })
    ).resolves.toBeUndefined();

    // Should log error
    expect(console.error).toHaveBeenCalledWith(
      expect.stringContaining('error setting item in storage')
    );
  });

  it('should handle network failures with retry', async () => {
    const networkError = new Error('Network timeout');
    global.fetch
      .mockRejectedValueOnce(networkError)
      .mockResolvedValueOnce({
        status: 200,
        json: () => Promise.resolve(1)
      });

    await MixpanelNetwork.sendRequest({
      token: 'test-token',
      endpoint: '/track/',
      data: [{ event: 'test' }],
      serverURL: 'https://api.mixpanel.com',
      useIPAddressForGeoLocation: true
    });

    expect(global.fetch).toHaveBeenCalledTimes(2);
  });

  it('should handle corrupted storage data', async () => {
    AsyncStorage.getItem.mockResolvedValue('invalid-json{');

    const result = await mixpanel.getSuperProperties();

    expect(result).toEqual({});
    expect(console.error).toHaveBeenCalledWith(
      expect.stringContaining('Failed to parse')
    );
  });

  it('should handle serialization errors', () => {
    const circularRef = {};
    circularRef.self = circularRef;

    expect(() => {
      mixpanel.${input:featureName}('parameter', { circular: circularRef });
    }).toThrow(); // Should throw during validation, not silently fail
  });
});
```

### 6. Integration Tests
```javascript
describe('Integration Tests', () => {
  beforeEach(async () => {
    mixpanel = new Mixpanel('test-token', true, false);
    await mixpanel.init();
  });

  it('should work with complete tracking pipeline', async () => {
    // Set up user context
    await mixpanel.identify('user123');
    await mixpanel.registerSuperProperties({ user_segment: 'premium' });

    // Test the feature
    mixpanel.${input:featureName}('test_parameter', { amount: 99.99, currency: 'USD' });

    // Verify complete event structure
    expect(MixpanelQueueManager.enqueue).toHaveBeenCalledWith(
      'test-token',
      MixpanelType.EVENTS,
      expect.objectContaining({
        event: 'test_parameter',
        properties: expect.objectContaining({
          amount: 99.99,
          currency: 'USD',
          user_segment: 'premium',
          distinct_id: 'user123',
          mp_lib: 'react-native',
          $lib_version: expect.any(String)
        })
      })
    );
  });

  it('should handle queue processing and network requests', async () => {
    // Add multiple events to queue
    for (let i = 0; i < 5; i++) {
      mixpanel.${input:featureName}(`parameter_${i}`, { index: i });
    }

    // Mock successful network response
    global.fetch.mockResolvedValue({
      status: 200,
      json: () => Promise.resolve(1)
    });

    // Trigger queue processing
    await mixpanel.flush();

    // Verify network request was made
    expect(global.fetch).toHaveBeenCalledWith(
      expect.stringContaining('https://api.mixpanel.com/track/'),
      expect.objectContaining({
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        body: expect.stringContaining('data=')
      })
    );

    // Verify queue was cleared after successful send
    expect(MixpanelQueueManager.spliceQueue).toHaveBeenCalledWith(
      'test-token',
      MixpanelType.EVENTS,
      0,
      5 // All 5 events should be removed
    );
  });
});
```

### 7. Multi-Token Tests
```javascript
describe('Multi-Token Support', () => {
  it('should isolate data between different tokens', async () => {
    const mixpanel1 = new Mixpanel('token1', true, false);
    const mixpanel2 = new Mixpanel('token2', true, false);

    await mixpanel1.init();
    await mixpanel2.init();

    // Set different properties for each token
    await mixpanel1.registerSuperProperties({ source: 'app1' });
    await mixpanel2.registerSuperProperties({ source: 'app2' });

    // Test the feature
    mixpanel1.${input:featureName}('parameter1', {});
    mixpanel2.${input:featureName}('parameter2', {});

    // Verify token isolation
    expect(MixpanelQueueManager.enqueue).toHaveBeenCalledWith(
      'token1', MixpanelType.EVENTS,
      expect.objectContaining({
        properties: expect.objectContaining({ source: 'app1' })
      })
    );

    expect(MixpanelQueueManager.enqueue).toHaveBeenCalledWith(
      'token2', MixpanelType.EVENTS,
      expect.objectContaining({
        properties: expect.objectContaining({ source: 'app2' })
      })
    );
  });
});
```

### 8. Performance Tests
```javascript
describe('Performance Tests', () => {
  beforeEach(() => {
    mixpanel = new Mixpanel('test-token', true, false);
  });

  it('should handle high-volume operations', async () => {
    const startTime = Date.now();
    
    // Perform 1000 operations
    for (let i = 0; i < 1000; i++) {
      mixpanel.${input:featureName}(`parameter_${i}`, { index: i });
    }
    
    const endTime = Date.now();
    const duration = endTime - startTime;
    
    // Should complete within reasonable time
    expect(duration).toBeLessThan(5000); // 5 seconds
    
    // Verify all operations were processed
    expect(MixpanelQueueManager.enqueue).toHaveBeenCalledTimes(1000);
  });
});
```

## Mock Updates Required

Update `__tests__/jest_setup.js`:
```javascript
jest.doMock("react-native", () => ({
  NativeModules: {
    MixpanelReactNative: {
      // ... existing methods
      ${input:featureName}: jest.fn().mockResolvedValue(undefined), // Add new method
    },
  },
}));
```

## Test Execution

Run the tests:
```bash
# Run specific test file
npm test -- __tests__/${input:featureName}.test.js

# Run tests in watch mode during development
npm test -- --watch __tests__/${input:featureName}.test.js

# Run with coverage
npm test -- --coverage __tests__/${input:featureName}.test.js
```

## Test Checklist

### Basic Coverage
- [ ] Input validation for all parameters
- [ ] Native mode implementation calls
- [ ] JavaScript mode queue management
- [ ] Error handling scenarios
- [ ] Mock verification and reset

### Advanced Coverage
- [ ] Integration with tracking pipeline
- [ ] Multi-token isolation
- [ ] Storage persistence testing
- [ ] Network request handling
- [ ] Performance under load

### Mock Maintenance
- [ ] Native module mocks updated
- [ ] AsyncStorage mocks configured
- [ ] Network mocks properly reset
- [ ] All external dependencies mocked

Reference our testing guide: `claude/workflows/02-testing-changes.md`
Use our standard patterns: `.github/copilot-instructions.md`