---
mode: 'agent'
tools: ['codebase', 'terminal']
description: 'Implement a new feature following dual-implementation patterns'
---

Implement a new feature named "${input:featureName}" in the Mixpanel React Native library.

## Feature Implementation Workflow

Follow this EXACT sequence for all new features:

### 1. Design Public API
- Update `index.d.ts` with TypeScript definitions
- Add method to main Mixpanel class in `index.js` with comprehensive input validation using StringHelper/ObjectHelper
- Use token as first parameter for all operations
- Follow camelCase naming convention

### 2. Implement iOS Native Version
- Add method to `ios/MixpanelReactNative.swift`
- Use `@objc` decorator with Promise pattern (resolver/rejecter)
- Include error handling for missing instances
- Use MixpanelTypeHandler for type conversion
- Call through to official Mixpanel iOS SDK

### 3. Implement Android Native Version  
- Add method to `android/src/main/java/com/mixpanel/reactnative/MixpanelReactNativeModule.java`
- Use `@ReactMethod` annotation with synchronized access
- Use ReactNativeHelper for type conversion
- Include comprehensive error handling

### 4. Implement JavaScript Fallback
- Add method to `javascript/mixpanel-main.js`
- Check opt-out status before ANY operation
- Add comprehensive logging with token context
- Use existing infrastructure (super properties, persistent storage)
- Follow async/await pattern consistently

### 5. Add Comprehensive Tests
- Test input validation for all parameter combinations
- Test native mode implementation calls
- Test JavaScript mode queue management
- Test opt-out behavior
- Test error handling scenarios
- Update native module mocks in `__tests__/jest_setup.js`

### 6. Update Documentation
- Add JSDoc comments with examples
- Update sample applications in `Samples/` directory
- Test integration in sample apps

## Requirements Checklist

### API Design
- [ ] TypeScript definitions added to `index.d.ts`
- [ ] Method added to main Mixpanel class with validation
- [ ] Token-based architecture followed
- [ ] Input validation using Helper classes

### Native Implementations
- [ ] iOS method with @objc decorator and Promise pattern
- [ ] Android method with @ReactMethod and synchronization
- [ ] Error handling for missing instances
- [ ] Type conversion using helper utilities

### JavaScript Implementation
- [ ] Method added to `javascript/mixpanel-main.js`
- [ ] Opt-out status checked before operations
- [ ] Comprehensive token-scoped logging
- [ ] Async/await pattern followed

### Testing
- [ ] Input validation tests for all parameters
- [ ] Native mode tests with mock verification
- [ ] JavaScript mode tests with queue validation
- [ ] Opt-out behavior testing
- [ ] Error handling scenario coverage
- [ ] Native module mocks updated

### Integration
- [ ] Sample applications updated and tested
- [ ] iOS pod install tested
- [ ] Android gradle build tested
- [ ] Documentation with examples added

## Key Patterns to Follow

### Input Validation Pattern
```javascript
if (!StringHelper.isValid(parameter)) {
  StringHelper.raiseError("parameter");
}
if (!ObjectHelper.isValidOrUndefined(properties)) {
  ObjectHelper.raiseError("properties");
}
```

### Implementation Routing Pattern
```javascript
// Route to appropriate implementation
this.mixpanelImpl.methodName(this.token, parameter, properties);
```

### iOS Native Pattern
```swift
@objc
func methodName(_ token: String,
                parameter: String,
                resolver resolve: RCTPromiseResolveBlock,
                rejecter reject: RCTPromiseRejectBlock) -> Void {
    let instance = MixpanelReactNative.getMixpanelInstance(token)
    guard let instance = instance else {
        reject("Instance Error", "Failed to get Mixpanel instance", nil)
        return
    }
    
    instance.nativeMethod(parameter: parameter)
    resolve(nil)
}
```

### Android Native Pattern
```java
@ReactMethod
public void methodName(final String token, 
                      String parameter, 
                      Promise promise) throws JSONException {
    MixpanelAPI instance = MixpanelAPI.getInstance(this.mReactContext, token, true);
    if (instance == null) {
        promise.reject("Instance Error", "Failed to get Mixpanel instance");
        return;
    }
    
    synchronized (instance) {
        instance.nativeMethod(parameter);
        promise.resolve(null);
    }
}
```

### JavaScript Implementation Pattern
```javascript
async methodName(token, parameter) {
  if (this.mixpanelPersistent.getOptedOut(token)) {
    MixpanelLogger.log(token, `User has opted out, skipping methodName`);
    return;
  }

  MixpanelLogger.log(token, `Calling methodName with parameter: ${parameter}`);
  // Implementation logic here
}
```

### Test Pattern
```javascript
describe('Feature Name', () => {
  describe('Native Mode', () => {
    it('should call native implementation', () => {
      mixpanel.methodName('parameter');
      expect(MixpanelReactNative.methodName).toHaveBeenCalledWith(
        'test-token', 'parameter'
      );
    });
  });

  describe('JavaScript Mode', () => {
    it('should implement JavaScript fallback', async () => {
      await mixpanel.methodName('parameter');
      // Verify JavaScript implementation behavior
    });
  });
});
```

## Testing Instructions

After implementation:
1. Run full test suite: `npm test`
2. Test in iOS sample app: `cd Samples/SimpleMixpanel && npx react-native run-ios`
3. Test in Android sample app: `cd Samples/SimpleMixpanel && npx react-native run-android`
4. Verify both native and JavaScript modes work correctly

Reference our architecture guide: `claude/architecture/system-design.md`
Use our standard patterns: `.github/copilot-instructions.md`

Ensure the feature maintains the library's reliability, performance, and compatibility standards while following all established architectural patterns.